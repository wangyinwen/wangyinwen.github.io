<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Elasticsearch系列(七)、ES集群的水平扩展记录</title>
    <link href="/2021/12/08/Elasticsearch%E7%B3%BB%E5%88%97(%E4%B8%83)%E3%80%81ES%E9%9B%86%E7%BE%A4%E7%9A%84%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/12/08/Elasticsearch%E7%B3%BB%E5%88%97(%E4%B8%83)%E3%80%81ES%E9%9B%86%E7%BE%A4%E7%9A%84%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>原来线上有三个机器，现在存储空间满了，需要扩容，最后在新建一个集群和对原集群水平扩充中选择了水平扩容。</p><p>基本和新搭建一个集群的步骤一样</p><p>可以参考</p><p><a href="https://wangyinwen.github.io/2021/08/05/Elasticsearch%E7%B3%BB%E5%88%97%28%E4%B8%80%29%E3%80%81Elasticsearch+filebeat+logstach+kibana%E6%9E%84%E5%BB%BA%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/">Elasticsearch系列(一)、Elasticsearch+filebeat+logstach+kibana构建日志服务平台</a></p><p><a href="https://wangyinwen.github.io/2021/08/20/Elasticsearch%E7%B3%BB%E5%88%97%28%E4%B8%89%29%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">Elasticsearch系列(三)、集群部署的相关问题记录</a></p><p>原es配置文件为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cluster<span class="hljs-selector-class">.name</span>: db-search<br>node<span class="hljs-selector-class">.name</span>: dc-search-es7-<span class="hljs-number">1</span><br>node<span class="hljs-selector-class">.data</span>: true<br>node<span class="hljs-selector-class">.master</span>: true<br>path<span class="hljs-selector-class">.data</span>: /data01/elasticsearch/data<br>path<span class="hljs-selector-class">.logs</span>: /data01/elasticsearch/log<br>network<span class="hljs-selector-class">.host</span>: <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br>http<span class="hljs-selector-class">.port</span>: <span class="hljs-number">9200</span><br>transport<span class="hljs-selector-class">.tcp</span><span class="hljs-selector-class">.port</span>: <span class="hljs-number">9300</span><br><br>discovery<span class="hljs-selector-class">.seed_hosts</span>: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;10.3.23.249:9300&quot;</span>,<span class="hljs-string">&quot;10.3.23.48:9300&quot;</span>,<span class="hljs-string">&quot;10.3.23.191:9300&quot;</span>]</span><br>cluster<span class="hljs-selector-class">.initial_master_nodes</span>: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;10.3.23.249:9300&quot;</span>,<span class="hljs-string">&quot;10.3.23.48:9300&quot;</span>,<span class="hljs-string">&quot;10.3.23.191:9300&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="要点记录"><a href="#要点记录" class="headerlink" title="要点记录"></a>要点记录</h2><ul><li>要在新节点中的/etc/hosts中添加老的三个节点的ip信息</li><li>上述配置文件只需更改node.name即可，至于node.master为true还是false，试过了都可以</li><li>es集群加入只是通过cluster.name来识别的，同一网段中根据集群名字来加入即可</li><li>这样做原来的集群不会停机，新节点进来之后会立即做blance</li><li>建议启动命令使用bin/elasticsearch -d后台启动</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/jerrymin/2501622">https://blog.51cto.com/jerrymin/2501622</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.15/add-elasticsearch-nodes.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.15/add-elasticsearch-nodes.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch系列(六)、Logstash解析工具dissect与grok用法解析</title>
    <link href="/2021/11/20/Elasticsearch%E7%B3%BB%E5%88%97(%E5%85%AD)%E3%80%81Logstash%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7dissect%E4%B8%8Egrok%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/11/20/Elasticsearch%E7%B3%BB%E5%88%97(%E5%85%AD)%E3%80%81Logstash%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7dissect%E4%B8%8Egrok%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="grok的用法"><a href="#grok的用法" class="headerlink" title="grok的用法"></a>grok的用法</h2><p>用例：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">grok &#123;<br>  <span class="hljs-built_in">match</span> =&gt; &#123;<br>    <span class="hljs-string">&quot;message&quot;</span> =&gt; &#x27;(?<span class="hljs-variable">&lt;time&gt;</span>.*) (?<span class="hljs-variable">&lt;pid&gt;</span>.*) (?<span class="hljs-variable">&lt;level&gt;</span>.*) (?<span class="hljs-variable">&lt;file&gt;</span>.*) (?<span class="hljs-variable">&lt;content&gt;</span>.*)&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际日志样例：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2012 </span><span class="hljs-number">666</span> INFO qwe.py caa<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>如果日志不满足正则表达式，比如<code>a b c</code>,这样只能分割出前三个字段，如果是这样，grok将不做解析，直接把<code>a b c</code>放到message字段里就完了</li><li>相反如果是不够分割的情况比如<code>a a a a a a a a a a a a a a c</code>，grok会把前面的字段放在一起，也就是说time字段会有多个a，而content字段是c，以此类推。</li></ul><h2 id="discet的用法"><a href="#discet的用法" class="headerlink" title="discet的用法"></a>discet的用法</h2><p>用例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">dissect &#123;<br>  <span class="hljs-string">mapping =&gt;</span> &#123;<br>    <span class="hljs-string">&quot;message&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;wang_time&#125; %&#123;wang_pid&#125; %&#123;wang_level&#125; %&#123;comtent&#125;&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果日志不满足正则表达式，比如<code>a b c</code>,这样只能分割出前三个字段，如果是这样，还未测试</li><li>相反如果是不够分割的情况比如<code>a a a a a a a a a a a a a a c</code>，discet会把后面的字段放在一起，也就是说content字段会有多个a加一个c</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>使用场景grok使用更广泛，比如在（）之间可用\s+（任意多个空格）来表示分割字符，但是dissect不行</li><li>grok的算法比dissect复杂，dissect是一种轻量化的正则表达式，耗时更短，速度更快</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch系列(五)、使用xpack进行安全认证和多租户管理</title>
    <link href="/2021/10/20/Elasticsearch%E7%B3%BB%E5%88%97(%E4%BA%94)%E3%80%81%E4%BD%BF%E7%94%A8xpack%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E5%92%8C%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <url>/2021/10/20/Elasticsearch%E7%B3%BB%E5%88%97(%E4%BA%94)%E3%80%81%E4%BD%BF%E7%94%A8xpack%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E5%92%8C%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="ELK的多租户管理"><a href="#ELK的多租户管理" class="headerlink" title="ELK的多租户管理"></a>ELK的多租户管理</h2><ul><li>要实现这个多租户管理，需要给elasticsearch启用xpack插件，这个插件在7.1以后的版本会随es直接安装且完全免费</li><li>单机部署比较简单，网上有很多帖子其实都是基于单机部署的，这里主要讲集群部署的步骤</li></ul><h3 id="1-修改ES配置文件并重启"><a href="#1-修改ES配置文件并重启" class="headerlink" title="1.修改ES配置文件并重启"></a>1.修改ES配置文件并重启</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">cluster</span>.name: db-<span class="hljs-keyword">search</span><br>node.name: dc-<span class="hljs-keyword">search</span>-es7<span class="hljs-number">-1</span><br><span class="hljs-type">path</span>.data: /data01/elasticsearch/data<br><span class="hljs-type">path</span>.logs: /data01/elasticsearch/<span class="hljs-keyword">log</span><br>network.host: <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>http.port: <span class="hljs-number">9200</span><br>transport.tcp.port: <span class="hljs-number">9300</span><br><br>discovery.seed_hosts: [&quot;10.3.23.249:9300&quot;,&quot;10.3.23.48:9300&quot;,&quot;10.3.23.191:9300&quot;]<br><span class="hljs-keyword">cluster</span>.initial_master_nodes: [&quot;10.3.23.249:9300&quot;,&quot;10.3.23.48:9300&quot;,&quot;10.3.23.191:9300&quot;]<br># 以下内容如果不需要用x-pack可以不用配置<br>xpack.<span class="hljs-keyword">security</span>.enabled: <span class="hljs-keyword">true</span><br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.enabled: <span class="hljs-keyword">true</span><br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.verification_mode: certificate<br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.keystore.path: elastic-certificates.p12<br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.truststore.path: elastic-certificates.p12<br></code></pre></td></tr></table></figure><ul><li><code>xpack.security.enabled</code>：表示开启xpack认证机制。</li><li><code>xpack.security.transport.ssl.enabled</code>：这条如果不配，es将起不来，会报如下错误:<code>Transport SSL must be enabled if security is enabled on a [basic] license. Please set [xpack.security.transport.ssl.enabled] to [true] or disable security by setting [xpack.security.enabled] to [false]</code></li><li>下面两条是证书文件存放路径，上面那样写代表是在config目录下</li><li>网上看到有些说添加配置<code>xpack.security.authc.accept_default_password: true</code>会自动生成默认密码：changeme。但是我试了一下没有成功</li></ul><h3 id="2-生成CA证书"><a href="#2-生成CA证书" class="headerlink" title="2.生成CA证书"></a>2.生成CA证书</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#进到es的安装目录，如果是yum安装或者rpm安装的默认是<span class="hljs-regexp">/usr/</span>share/elasticsearch下<br>[root@localhost ~]# cd <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span><br> <br>#生成CA证书，遇到账号密码回车即可<br>[root@localhost elasticsearch]# bin/elasticsearch-certutil ca<br> <br>#生成节点证书，遇到账号密码回车即可<br>[root@localhost elasticsearch]# bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12<br> <br>#生成证书到配置文件目录<span class="hljs-regexp">/etc/</span>elasticsearch下<br>[root@localhost elasticsearch]# bin<span class="hljs-regexp">/elasticsearch-certutil cert -out /</span>etc<span class="hljs-regexp">/elasticsearch/</span>elastic-certificates.p12 -pass<br>#上面命令执行成功后，会在`<span class="hljs-regexp">/etc/</span>elasticsearch/`文件夹下生成elastic-certificates.p12证书<br></code></pre></td></tr></table></figure><p>把<code>/etc/elasticsearch/</code>文件夹下生成elastic-certificates.p12证书拷贝到elasticsearch/config文件夹下，并chown修改权限</p><h3 id="3-CA证书拷贝"><a href="#3-CA证书拷贝" class="headerlink" title="3.CA证书拷贝"></a>3.CA证书拷贝</h3><p>上述第二步在一个节点直接就行，然后把生成的那个文件拷贝到其他节点的相同位置，注意调整权限，否则会报错</p><h3 id="4-密码设置"><a href="#4-密码设置" class="headerlink" title="4.密码设置"></a>4.密码设置</h3><p>这个密码设置只需要在一个节点配置就行</p><p>执行：<code>/usr/share/elasticsearch/bin/elasticsearch-setup-passwords interactive</code></p><h3 id="5-配置kibana，并重启"><a href="#5-配置kibana，并重启" class="headerlink" title="5.配置kibana，并重启"></a>5.配置kibana，并重启</h3><p>在kibana配置文件中添加下面两行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">elasticsearch.username: <span class="hljs-string">&quot;kibana&quot;</span><br>elasticsearch.password: <span class="hljs-string">&quot;kibana_passwd&quot;</span><br></code></pre></td></tr></table></figure><p>参考：<a href="https://wiki.eryajf.net/pages/3500.html#_3-%E9%85%8D%E7%BD%AEkibana%E8%BF%9E%E6%8E%A5%E3%80%82">https://wiki.eryajf.net/pages/3500.html#_3-%E9%85%8D%E7%BD%AEkibana%E8%BF%9E%E6%8E%A5%E3%80%82</a></p><p><a href="https://www.lixian.fun/4928.html">https://www.lixian.fun/4928.html</a></p><h2 id="kibana层面的工作空间（space），用户（user）、角色（role）等配置"><a href="#kibana层面的工作空间（space），用户（user）、角色（role）等配置" class="headerlink" title="kibana层面的工作空间（space），用户（user）、角色（role）等配置"></a>kibana层面的工作空间（space），用户（user）、角色（role）等配置</h2><ul><li>工作空间的作用应该是保证不同用户在不同空间里工作（好像是废话）</li><li>角色可能包含多个工作空间，用户可能包含多个角色</li><li>角色里可以配置不同角色对不同索引的操作权限</li><li>elastic用户是super用户，用这个账号登录再进行其他账号权限的配置</li></ul><p>参考：<a href="https://www.cnblogs.com/sanduzxcvbnm/p/12074772.html">https://www.cnblogs.com/sanduzxcvbnm/p/12074772.html</a></p><p><a href="https://www.cnblogs.com/sanduzxcvbnm/p/11427692.html">https://www.cnblogs.com/sanduzxcvbnm/p/11427692.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch系列(四)、查询相关总结以及timestamp和时区问题</title>
    <link href="/2021/08/25/Elasticsearch%E7%B3%BB%E5%88%97(%E5%9B%9B)%E3%80%81%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8Atimestamp%E5%92%8C%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/25/Elasticsearch%E7%B3%BB%E5%88%97(%E5%9B%9B)%E3%80%81%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8Atimestamp%E5%92%8C%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="ES查询相关"><a href="#ES查询相关" class="headerlink" title="ES查询相关"></a>ES查询相关</h2><p>参考：<a href="https://www.cnblogs.com/qdhxhz/p/11493677.html">https://www.cnblogs.com/qdhxhz/p/11493677.html</a></p><ul><li><p>如果想筛选出特定时间段的event，可以在查询语句里使用<code>post_filter</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST <span class="hljs-regexp">/wangtest_re/</span>_search<br>&#123;<br>  <span class="hljs-string">&quot;post_filter&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;@timestamp&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-string">&quot;2012-08-01T15:00:00.000+800&quot;</span>,<br>        <span class="hljs-string">&quot;lte&quot;</span>: <span class="hljs-string">&quot;2012-08-01T15:00:00.000+800&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>也可以把range写在query语句里，但是用户使用where语句的时候，也是放置在query里的，所以无法预知客户的输入，所以range语句放不进去</p></li><li><p>post_filter，是查询后再过滤的，因为不需要计算score，所以速度更快，而且数据会缓存</p></li></ul><h2 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h2><p>参考：<a href="https://segmentfault.com/a/1190000022064788">https://segmentfault.com/a/1190000022064788</a></p><p><a href="https://blog.csdn.net/lijingjingchn/article/details/100576088">https://blog.csdn.net/lijingjingchn/article/details/100576088</a></p><ul><li><p>时间戳：unix时间戳是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒</p></li><li><p>因为给用户看UTC时间不合适，所以最好的做法是，让es输出时间戳，后台根据时间戳再转换成2021-12-12 12:12:12的格式</p></li></ul><p>时间戳和时间转换代码：</p><p><a href="https://felix.blog.csdn.net/article/details/51355282">https://felix.blog.csdn.net/article/details/51355282</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding:UTF-8</span><br><span class="hljs-keyword">import</span> time<br><br>timestamp = <span class="hljs-number">1462451334</span> <span class="hljs-comment"># 如果需要格式转换，这里用float格式</span><br><br><span class="hljs-comment">#转换成localtime</span><br>time_local = time.localtime(timestamp)<br><span class="hljs-comment">#转换成新的时间格式(2016-05-05 20:28:54)</span><br>dt = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,time_local)<br><br><span class="hljs-built_in">print</span>(dt)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch系列(三)、集群部署的相关问题记录</title>
    <link href="/2021/08/20/Elasticsearch%E7%B3%BB%E5%88%97(%E4%B8%89)%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/08/20/Elasticsearch%E7%B3%BB%E5%88%97(%E4%B8%89)%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="ElasticSearch相关的端口"><a href="#ElasticSearch相关的端口" class="headerlink" title="ElasticSearch相关的端口"></a>ElasticSearch相关的端口</h2><ul><li>ES：9200。作为http协议，主要用于外部通信</li><li>ES：9300。作为TCP协议，jar之间就是通过 tcp协议通信，ES集群之间通过9300通信</li><li>Kibana：5601</li><li>Logstash：5044</li><li>cerebro: 9000</li></ul><h2 id="ES启动时遇到的问题"><a href="#ES启动时遇到的问题" class="headerlink" title="ES启动时遇到的问题"></a>ES启动时遇到的问题</h2><p><strong>问题1：</strong></p><pre><code>java.nio.file.AccessDeniedException</code></pre><p>一般是文件权限的问题，一定要chown -Relasticsearch这个文件夹，其次如果设定了数据存储路径，如果外挂磁盘的话，需要把这个数据存储路径的权限也加一下</p><p><strong>问题2：</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">ERROR: [2] bootstrap checks failed.You must address the points described in the following [2] lines before starting Elasticsearch.<br>bootstrap<span class="hljs-built_in"> check </span>failure [1] of [2]:max file descriptors [4096] for elasticsearch process is too low,increase to at least [65535]<br>bootstrap<span class="hljs-built_in"> check </span>failure [2] of [2]:max virtual memory areas vm.max_map_count [65530] is too low,increase to at least [262144]<br>ERROR: Elasticsearch did<span class="hljs-built_in"> not </span>exit normally -<span class="hljs-built_in"> check </span>the logs at /root/elasticsearch-7.13.3/logs/sahoc_es.log<br></code></pre></td></tr></table></figure><p><strong>解决方案</strong></p><ol><li><p>编辑/etc/sysctl.conf,追加下面的内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">vm.max_map_count</span>=<span class="hljs-number">655360</span><br><span class="hljs-attr">net.core.somaxconn</span>=<span class="hljs-number">60000</span><br></code></pre></td></tr></table></figure><p>执行<code>sysctl -p</code></p><p>vm.max_map_count代表限制一个进程可以拥有的VMA（虚拟内存区域）的数量</p><blockquote><p>net.core.somaxconn 介绍<br>1）概念介绍<br>  对于一个TCP链接，Server与Client需要通过三次握手来建立网络链接，当三次握手成功之后，我们就可以看到端口状态由LISTEN转为ESTABLISHED，接着这条链路上就可以开始传送数据了</p><p>net.core.somaxconn是Linux中的一个内核(kernel)参数，表示socket监听(listen)的backlog上限。<br>什么是backlog？backlog就是socket的监听队列，当一个请求(request)尚未被处理或者建立时，它就会进入backlog。<br>而socket server可以一次性处理backlog中的所有请求，处理后的请求不再位于监听队列中。<br>当Server处理请求较慢时，导致监听队列被填满后，新来的请求就会被拒绝。</p><p>2）补充<br>Linux系统中，该参数的值默认是128<br>如果Linux系统中部署了经常处理新请求(request)的高负载的服务，那么显然这个值是需要增加到更合适的值的</p></blockquote></li><li><p>编辑/etc/security/limits.conf,追加一下内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">   *</span> sotf nofile 655360<br><span class="hljs-bullet">   *</span> hard nofile 655360<br><span class="hljs-bullet">   *</span> sotf nproc 655360<br><span class="hljs-bullet">*</span> hard nproc 655360<br></code></pre></td></tr></table></figure><p>linux资源限制配置文件是/etc/security/limits.conf；限制用户进程的数量对于linux系统的稳定性非常重要。 limits.conf文件限制着用户可以使用的最大文件数，最大线程，最大内存等资源使用量。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mel">   * <span class="hljs-keyword">soft</span> nofile <span class="hljs-number">655350</span>  #任何用户可以打开的最大的文件描述符数量，默认<span class="hljs-number">1024</span>，这里的数值会限制tcp连接<br>   * hard nofile <span class="hljs-number">655350</span><br>   * <span class="hljs-keyword">soft</span> nproc  <span class="hljs-number">655350</span>  #任何用户可以打开的最大进程数<br>   * hard nproc  <span class="hljs-number">650000</span><br>   <br>   @student hard nofile <span class="hljs-number">65535</span><br>   @student <span class="hljs-keyword">soft</span> nofile <span class="hljs-number">4096</span><br>   @student hard nproc <span class="hljs-number">50</span>  #学生组中的任何人不能拥有超过<span class="hljs-number">50</span>个进程，并且会在拥有<span class="hljs-number">30</span>个进程时发出警告<br>@student <span class="hljs-keyword">soft</span> nproc <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><ul><li>hard和soft两个值都代表什么意思呢？ soft是一个警告值，而hard则是一个真正意义的阀值，超过就会报错</li></ul><p>参考：<a href="https://cloud.tencent.com/developer/article/1403636">https://cloud.tencent.com/developer/article/1403636</a></p></li></ol><h2 id="ES内存相关（监控页面的heap）"><a href="#ES内存相关（监控页面的heap）" class="headerlink" title="ES内存相关（监控页面的heap）"></a>ES内存相关（监控页面的heap）</h2><p>不改不会报错，改了性能会更好？</p><p>参考：<a href="https://elasticsearch.cn/article/32">https://elasticsearch.cn/article/32</a></p><p>一般把ES内存设置为整台机器内存的一半</p><p>如何修改ES内存？</p><p>编辑config/jvm.options文件</p><p>把里面的</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms4g</span><br><span class="hljs-deletion">-Xmx4g</span><br></code></pre></td></tr></table></figure><p>取消注释，并把4g改成8g即可，默认是1g</p>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch系列(二)、集群部署时配置文件详解</title>
    <link href="/2021/08/11/Elasticsearch%E7%B3%BB%E5%88%97(%E4%BA%8C)%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%97%B6%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/11/Elasticsearch%E7%B3%BB%E5%88%97(%E4%BA%8C)%E3%80%81%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%97%B6%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="ElasticSearch配置文件解析"><a href="#ElasticSearch配置文件解析" class="headerlink" title="ElasticSearch配置文件解析"></a>ElasticSearch配置文件解析</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><code class="hljs clean">##################### Elasticsearch Configuration Example ##################### <br>#<br># 只是挑些重要的配置选项进行注释,其实自带的已经有非常细致的英文注释了!<br># https:<span class="hljs-comment">//www.elastic.co/guide/en/elasticsearch/reference/current/modules.html</span><br>#<br>################################### Cluster ################################### <br># 代表一个集群,集群中有多个节点,其中有一个为主节点,这个主节点是可以通过选举产生的,主从节点是对于集群内部来说的. <br># es的一个概念就是去中心化,字面上理解就是无中心节点,这是对于集群外部来说的,因为从外部来看es集群,在逻辑上是个整体,你与任何一个节点的通信和与整个es集群通信是等价的。 <br># cluster.name可以确定你的集群名称,当你的elasticsearch集群在同一个网段中elasticsearch会自动的找到具有相同cluster.name的elasticsearch服务. <br># 所以当同一个网段具有多个elasticsearch集群时cluster.name就成为同一个集群的标识. <br><br># cluster.name: elasticsearch <br><br>#################################### Node ##################################### <br># https:<span class="hljs-comment">//www.elastic.co/guide/en/elasticsearch/reference/5.1/modules-node.html#master-node</span><br># 节点名称同理,可自动生成也可手动配置. <br># node.name: node<span class="hljs-number">-1</span><br><br># 允许一个节点是否可以成为一个master节点,es是默认集群中的第一台机器为master,如果这台机器停止就会重新选举master. <br># node.master: true <br><br># 允许该节点存储数据(默认开启) <br># node.data: true <br><br># 配置文件中给出了三种配置高性能集群拓扑结构的模式,如下： <br># <span class="hljs-number">1.</span> 如果你想让节点从不选举为主节点,只用来存储数据,可作为负载器 <br># node.master: false <br># node.data: true <br># node.ingest: true  #默认true<br><br># <span class="hljs-number">2.</span> 如果想让节点成为主节点,且不存储任何数据,并保有空闲资源,可作为协调器 <br># node.master: true <br># node.data: false<br># node.ingest: true<br><br># <span class="hljs-number">3.</span> 如果想让节点既不称为主节点,又不成为数据节点,那么可将他作为搜索器,从节点中获取数据,生成搜索结果等 <br># node.master: false <br># node.data: false <br># node.ingest: true<br>#<br><br># <span class="hljs-number">4.</span> 仅作为协调器 <br># node.master: false <br># node.data: false<br># node.ingest: false<br><br># 监控集群状态有一下插件和API可以使用: <br># Use the Cluster Health API [http:<span class="hljs-comment">//localhost:9200/_cluster/health], the </span><br># Node Info API [http:<span class="hljs-comment">//localhost:9200/_nodes] or GUI tools # such as &lt;http://www.elasticsearch.org/overview/marvel/&gt;, </span><br><br><br># A node can have <span class="hljs-keyword">generic</span> attributes associated <span class="hljs-keyword">with</span> it, which can later be used <br># for customized shard allocation filtering, or allocation awareness. An attribute <br># is a simple key value pair, similar to node.key: value, here is an example: <br># 每个节点都可以定义一些与之关联的通用属性，用于后期集群进行碎片分配时的过滤<br># node.rack: rack314 <br><br># 默认情况下，多个节点可以在同一个安装路径启动，如果你想让你的es只启动一个节点，可以进行如下设置<br># node.max_local_storage_nodes: <span class="hljs-number">1</span> <br><br>#################################### Index #################################### <br># 设置索引的分片数,默认为<span class="hljs-number">5</span> <br>#index.number_of_shards: <span class="hljs-number">5</span> <br><br># 设置索引的副本数,默认为<span class="hljs-number">1</span>: <br>#index.number_of_replicas: <span class="hljs-number">1</span> <br><br># 配置文件中提到的最佳实践是,如果服务器够多,可以将分片提高,尽量将数据平均分布到大集群中去<br># 同时,如果增加副本数量可以有效的提高搜索性能 <br># 需要注意的是,<span class="hljs-string">&quot;number_of_shards&quot;</span> 是索引创建后一次生成的,后续不可更改设置 <br># <span class="hljs-string">&quot;number_of_replicas&quot;</span> 是可以通过API去实时修改设置的 <br><br>#################################### Paths #################################### <br># 配置文件存储位置 <br># path.conf: /path/to/conf <br><br># 数据存储位置(单个目录设置) <br># path.data: /path/to/data <br># 多个数据存储位置,有利于性能提升 <br># path.data: /path/to/data1,/path/to/data2 <br><br># 临时文件的路径 <br># path.work: /path/to/work <br><br># 日志文件的路径 <br># path.logs: /path/to/logs <br><br># 插件安装路径 <br># path.plugins: /path/to/plugins <br><br>#################################### Plugin ################################### <br># 设置插件作为启动条件,如果一下插件没有安装,则该节点服务不会启动 <br># plugin.mandatory: mapper-attachments,lang-groovy <br><br>################################### Memory #################################### <br># 当JVM开始写入交换空间时（swapping）ElasticSearch性能会低下,你应该保证它不会写入交换空间 <br># 设置这个属性为true来锁定内存,同时也要允许elasticsearch的进程可以锁住内存,linux下可以通过 `ulimit -l unlimited` 命令 <br># bootstrap.mlockall: true <br><br># 确保 ES_MIN_MEM 和 ES_MAX_MEM 环境变量设置为相同的值,以及机器有足够的内存分配给Elasticsearch <br># 注意:内存也不是越大越好,一般<span class="hljs-number">64</span>位机器,最大分配内存别才超过<span class="hljs-number">32</span>G <br><br>############################## Network And HTTP ############################### <br># 设置绑定的ip地址,可以是ipv4或ipv6的,默认为<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <br># network.bind_host: <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>   #只有本机可以访问http接口<br><br># 设置其它节点和该节点交互的ip地址,如果不设置它会自动设置,值必须是个真实的ip地址 <br># network.publish_host: <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <br><br># 同时设置bind_host和publish_host上面两个参数 <br># network.host: <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>    #绑定监听IP<br><br># 设置节点间交互的tcp端口,默认是<span class="hljs-number">9300</span> <br># transport.tcp.port: <span class="hljs-number">9300</span> <br><br># 设置是否压缩tcp传输时的数据，默认为false,不压缩<br># transport.tcp.compress: true <br><br># 设置对外服务的http端口,默认为<span class="hljs-number">9200</span> <br># http.port: <span class="hljs-number">9200</span> <br><br># 设置请求内容的最大容量,默认<span class="hljs-number">100</span>mb <br># http.max_content_length: <span class="hljs-number">100</span>mb <br><br># 使用http协议对外提供服务,默认为true,开启 <br># http.enabled: false <br><br>###################### 使用head等插件监控集群信息，需要打开以下配置项 ###########<br># http.cors.enabled: true<br># http.cors.allow-origin: <span class="hljs-string">&quot;*&quot;</span><br># http.cors.allow-credentials: true<br><br>################################### Gateway ################################### <br># gateway的类型,默认为local即为本地文件系统,可以设置为本地文件系统 <br># gateway.type: local <br><br># 下面的配置控制怎样以及何时启动一整个集群重启的初始化恢复过程 <br># (当使用shard gateway时,是为了尽可能的重用local data(本地数据)) <br><br># 一个集群中的N个节点启动后,才允许进行恢复处理 <br># gateway.recover_after_nodes: <span class="hljs-number">1</span> <br><br># 设置初始化恢复过程的超时时间,超时时间从上一个配置中配置的N个节点启动后算起 <br># gateway.recover_after_time: <span class="hljs-number">5</span>m <br><br># 设置这个集群中期望有多少个节点.一旦这N个节点启动(并且recover_after_nodes也符合), <br># 立即开始恢复过程(不等待recover_after_time超时) <br># gateway.expected_nodes: <span class="hljs-number">2</span><br><br> ############################# Recovery Throttling ############################# <br># 下面这些配置允许在初始化恢复,副本分配,再平衡,或者添加和删除节点时控制节点间的分片分配 <br># 设置一个节点的并行恢复数 <br># <span class="hljs-number">1.</span>初始化数据恢复时,并发恢复线程的个数,默认为<span class="hljs-number">4</span> <br># cluster.routing.allocation.node_initial_primaries_recoveries: <span class="hljs-number">4</span> <br><br># <span class="hljs-number">2.</span>添加删除节点或负载均衡时并发恢复线程的个数,默认为<span class="hljs-number">2</span> <br># cluster.routing.allocation.node_concurrent_recoveries: <span class="hljs-number">2</span> <br><br># 设置恢复时的吞吐量(例如:<span class="hljs-number">100</span>mb,默认为<span class="hljs-number">0</span>无限制.如果机器还有其他业务在跑的话还是限制一下的好) <br># indices.recovery.max_bytes_per_sec: <span class="hljs-number">20</span>mb <br><br># 设置来限制从其它分片恢复数据时最大同时打开并发流的个数,默认为<span class="hljs-number">5</span> <br># indices.recovery.concurrent_streams: <span class="hljs-number">5</span> <br># 注意: 合理的设置以上参数能有效的提高集群节点的数据恢复以及初始化速度 <br><br>################################## Discovery ################################## <br># 设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点.默认为<span class="hljs-number">1</span>,对于大的集群来说,可以设置大一点的值(<span class="hljs-number">2</span><span class="hljs-number">-4</span>) <br># discovery.zen.minimum_master_nodes: <span class="hljs-number">1</span> <br># 探查的超时时间,默认<span class="hljs-number">3</span>秒,提高一点以应对网络不好的时候,防止脑裂 <br># discovery.zen.ping.timeout: <span class="hljs-number">3</span>s <br><br># For more information, see <br># &lt;http:<span class="hljs-comment">//elasticsearch.org/guide/en/elasticsearch/reference/current/modules-discovery-zen.html&gt; </span><br><br># 设置是否打开多播发现节点.默认是true. <br># 当多播不可用或者集群跨网段的时候集群通信还是用单播吧 <br># discovery.zen.ping.multicast.enabled: false <br><br># 这是一个集群中的主节点的初始列表,当节点(主节点或者数据节点)启动时使用这个列表进行探测 <br># discovery.zen.ping.unicast.hosts: [<span class="hljs-string">&quot;host1&quot;</span>, <span class="hljs-string">&quot;host2:port&quot;</span>] <br><br># Slow Log部分与GC log部分略,不过可以通过相关日志优化搜索查询速度 <br><br>################  X-Pack ###########################################<br># 官方插件 相关设置请查看此处<br># https:<span class="hljs-comment">//www.elastic.co/guide/en/x-pack/current/xpack-settings.html</span><br># <br>############## Memory(重点需要调优的部分) ################ <br># Cache部分: <br># es有很多种方式来缓存其内部与索引有关的数据.其中包括filter cache <br><br># filter cache部分: <br># filter cache是用来缓存filters的结果的.默认的cache type是node type.node type的机制是所有的索引内部的分片共享filter cache.node type采用的方式是LRU方式.即:当缓存达到了某个临界值之后，es会将最近没有使用的数据清除出filter cache.使让新的数据进入es. <br><br># 这个临界值的设置方法如下：indices.cache.filter.size 值类型：eg.:<span class="hljs-number">512</span>mb <span class="hljs-number">20</span>%。默认的值是<span class="hljs-number">10</span>%。 <br><br># out <span class="hljs-keyword">of</span> memory错误避免过于频繁的查询时集群假死 <br># <span class="hljs-number">1.</span>设置es的缓存类型为Soft Reference,它的主要特点是据有较强的引用功能.只有当内存不够的时候,才进行回收这类内存,因此在内存足够的时候,它们通常不被回收.另外,这些引用对象还能保证在Java抛出OutOfMemory异常之前,被设置为null.它可以用于实现一些常用图片的缓存,实现Cache的功能,保证最大限度的使用内存而不引起OutOfMemory.在es的配置文件加上index.cache.field.type: soft即可. <br><br># <span class="hljs-number">2.</span>设置es最大缓存数据条数和缓存失效时间,通过设置index.cache.field.max_size: <span class="hljs-number">50000</span>来把缓存field的最大值设置为<span class="hljs-number">50000</span>,设置index.cache.field.expire: <span class="hljs-number">10</span>m把过期时间设置成<span class="hljs-number">10</span>分钟. <br># index.cache.field.max_size: <span class="hljs-number">50000</span> <br># index.cache.field.expire: <span class="hljs-number">10</span>m <br># index.cache.field.type: soft <br><br># field data部分&amp;&amp;circuit breaker部分： <br># 用于fielddata缓存的内存数量,主要用于当使用排序,faceting操作时,elasticsearch会将一些热点数据加载到内存中来提供给客户端访问,但是这种缓存是比较珍贵的,所以对它进行合理的设置. <br><br># 可以使用值：eg:<span class="hljs-number">50</span>mb 或者 <span class="hljs-number">30</span>％(节点 node heap内存量),默认是：unbounded #indices.fielddata.cache.size： unbounded <br># field的超时时间.默认是<span class="hljs-number">-1</span>,可以设置的值类型: <span class="hljs-number">5</span>m #indices.fielddata.cache.expire: <span class="hljs-number">-1</span> <br><br># circuit breaker部分: <br># 断路器是elasticsearch为了防止内存溢出的一种操作,每一种circuit breaker都可以指定一个内存界限触发此操作,这种circuit breaker的设定有一个最高级别的设定:indices.breaker.total.limit 默认值是JVM heap的<span class="hljs-number">70</span>%.当内存达到这个数量的时候会触发内存回收<br><br># 另外还有两组子设置： <br>#indices.breaker.fielddata.limit:当系统发现fielddata的数量达到一定数量时会触发内存回收.默认值是JVM heap的<span class="hljs-number">70</span>% <br>#indices.breaker.fielddata.overhead:在系统要加载fielddata时会进行预先估计,当系统发现要加载进内存的值超过limit * overhead时会进行进行内存回收.默认是<span class="hljs-number">1.03</span> <br>#indices.breaker.request.limit:这种断路器是elasticsearch为了防止OOM(内存溢出),在每次请求数据时设定了一个固定的内存数量.默认值是<span class="hljs-number">40</span>% <br>#indices.breaker.request.overhead:同上,也是elasticsearch在发送请求时设定的一个预估系数,用来防止内存溢出.默认值是<span class="hljs-number">1</span> <br><br># Translog部分: <br># 每一个分片(shard)都有一个transaction log或者是与它有关的预写日志,(write log),在es进行索引(index)或者删除(delete)操作时会将没有提交的数据记录在translog之中,当进行flush 操作的时候会将tranlog中的数据发送给Lucene进行相关的操作.一次flush操作的发生基于如下的几个配置 <br>#index.translog.flush_threshold_ops:当发生多少次操作时进行一次flush.默认是 unlimited #index.translog.flush_threshold_size:当translog的大小达到此值时会进行一次flush操作.默认是<span class="hljs-number">512</span>mb <br>#index.translog.flush_threshold_period:在指定的时间间隔内如果没有进行flush操作,会进行一次强制flush操作.默认是<span class="hljs-number">30</span>m #index.translog.interval:多少时间间隔内会检查一次translog,来进行一次flush操作.es会随机的在这个值到这个值的<span class="hljs-number">2</span>倍大小之间进行一次操作,默认是<span class="hljs-number">5</span>s <br>#index.gateway.local.sync:多少时间进行一次的写磁盘操作,默认是<span class="hljs-number">5</span>s <br><br></code></pre></td></tr></table></figure><h1 id="集群不同角色节点的作用"><a href="#集群不同角色节点的作用" class="headerlink" title="集群不同角色节点的作用"></a>集群不同角色节点的作用</h1><p><a href="https://juejin.cn/post/6844903873153335309">https://juejin.cn/post/6844903873153335309</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;mid=2247483896&amp;idx=1&amp;sn=c55b031b813ee4badbc10d62df84eaf0&amp;chksm=eaa829d0dddfa0c6fdd095abf55fd42f2a9cbc26ee61710f7d558f03143253ebdf5e0c73f0f2&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&amp;mid=2247483896&amp;idx=1&amp;sn=c55b031b813ee4badbc10d62df84eaf0&amp;chksm=eaa829d0dddfa0c6fdd095abf55fd42f2a9cbc26ee61710f7d558f03143253ebdf5e0c73f0f2&amp;scene=21#wechat_redirect</a></p><h1 id="关于-Elasticsearch-集群核心配置，腾讯大佬的灵魂9问，你能接住几个？"><a href="#关于-Elasticsearch-集群核心配置，腾讯大佬的灵魂9问，你能接住几个？" class="headerlink" title="关于 Elasticsearch 集群核心配置，腾讯大佬的灵魂9问，你能接住几个？"></a>关于 Elasticsearch 集群核心配置，腾讯大佬的灵魂9问，你能接住几个？</h1><h1 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h1><p><a href="https://jishuin.proginn.com/p/763bfbd3475a">https://jishuin.proginn.com/p/763bfbd3475a</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch系列(一)、Elasticsearch+filebeat+logstach+kibana构建日志服务平台</title>
    <link href="/2021/08/05/Elasticsearch%E7%B3%BB%E5%88%97(%E4%B8%80)%E3%80%81Elasticsearch+filebeat+logstach+kibana%E6%9E%84%E5%BB%BA%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/"/>
    <url>/2021/08/05/Elasticsearch%E7%B3%BB%E5%88%97(%E4%B8%80)%E3%80%81Elasticsearch+filebeat+logstach+kibana%E6%9E%84%E5%BB%BA%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>devops中日志服务的搭建</li><li>收集各个节点（agent）的日志文件进ES集群，并提供分析和查询的服务</li><li>各个agent的filebeat收集服务不能终断，也就是需要动态reload配置文件</li><li>支持用户设置分隔符划分和正则匹配两种方式添加field字段</li></ul><h1 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h1><ul><li>将filebeat部署在agent节点，master节点控制agent节点的配置文件，filebeat很轻量</li><li>因为filebeat的配置文件支持reload的只有input和moudel两个模块，但是需要对用户提供的分隔符和正则表达式进行处理，可以完成这个操作的processors模块不支持动态reload，所以filebeat只收集日志，处理日志的任务交给logstach，logstach支持整个配置文件的动态reload</li></ul><h2 id="Filebeat安装以及使用"><a href="#Filebeat安装以及使用" class="headerlink" title="Filebeat安装以及使用"></a>Filebeat安装以及使用</h2><ul><li><p>Filebeat是一个轻量化的日志收集工具，对标Logstach，filebeat只有30M，而logstach有300M</p></li><li><p>调试启动命令：<code>./filebeat -e -c filebeat.yml</code>,-c指明配置文件路径，-e表示记录到stderr，并禁用syslog文件输出</p></li><li><p>启动命令相关：<a href="https://johng.cn/filebeat-command-configuration/">https://johng.cn/filebeat-command-configuration/</a></p></li><li><p>后台启动方式：<code>nohup ./filebeat -e -c filebeat.yml &gt; filebeat.log &amp;</code></p></li><li><p>filebeat启动可以使用root用户，但是ES启动不能使用root用户</p></li><li><p>reload相关写法参考：<a href="https://blog.csdn.net/junxuezheng/article/details/108349689">https://blog.csdn.net/junxuezheng/article/details/108349689</a></p></li><li><p>filebeat.yml配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">filebeat.config.inputs:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/usr/local/xxx/input.yml</span><br>  <span class="hljs-attr">reload.enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">reload.period:</span> <span class="hljs-string">5s</span><br><br><span class="hljs-attr">output.console:</span><br>  <span class="hljs-attr">pretty:</span> <span class="hljs-literal">true</span><br>  <br><span class="hljs-comment">#output.elasticsearch:</span><br><span class="hljs-comment">#  hosts: [&quot;10.243.65.186:9200&quot;]</span><br><br><span class="hljs-attr">output.logstash:</span><br>  <span class="hljs-attr">hosts:</span> [<span class="hljs-string">&quot;1.1.1.186:5044&quot;</span>]<br><span class="hljs-attr">processors:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">rename:</span><br>    <span class="hljs-attr">fields:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span> <span class="hljs-string">host</span><br>      <span class="hljs-attr">to:</span> <span class="hljs-string">_host</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span> <span class="hljs-string">message</span><br>      <span class="hljs-attr">to:</span> <span class="hljs-string">_message</span><br>    <span class="hljs-attr">ignore_missing:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">fail_on_error:</span> <span class="hljs-literal">true</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">drop_fields:</span><br>    <span class="hljs-attr">fields:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ecs</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">log</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">input</span><br></code></pre></td></tr></table></figure></li><li><p>input.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">log</span><br><br>  <span class="hljs-comment"># Change to true to enable this input configuration.</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># Paths that should be crawled and fetched. Glob based paths.</span><br>  <span class="hljs-attr">paths:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/xxx</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">c7f1771f-0c8f-4c75-9d71-3b8c4b6bd191</span><br>  <span class="hljs-attr">fields:</span> <br>    <span class="hljs-attr">_host.name:</span> <span class="hljs-string">wang_test</span><br>  <span class="hljs-attr">fields_under_root:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>注意上面的fields,host和name中间的那个点，这样会产生的效果是一个字典，如果使用<code>GET master_common/_search</code>查询的话显示的是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br><span class="hljs-attr">&quot;hits&quot;:</span> [<br>&#123;<br><span class="hljs-attr">&quot;_index&quot;:</span> <span class="hljs-string">xxx</span>,<br><span class="hljs-attr">&quot;_type&quot;:</span> <span class="hljs-string">xxx</span>,<br><span class="hljs-attr">&quot;_source&quot;:</span> &#123;<br><span class="hljs-attr">&quot;pid&quot;:</span> <span class="hljs-string">xxx</span>,<br><span class="hljs-attr">&quot;level&quot;:</span> <span class="hljs-string">xxx</span>,<br><span class="hljs-attr">&quot;_host&quot;:</span> &#123;<br><span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">xxx</span><br>&#125;<br>&#125;<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p>但是通过sql语句转换再查询，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">POST</span> <span class="hljs-string">master/_search</span><br>&#123;<br><span class="hljs-attr">&quot;size&quot;:</span> <span class="hljs-number">2</span>,<br><span class="hljs-attr">&quot;from&quot;:</span> <span class="hljs-number">1</span>,<br><span class="hljs-attr">&quot;field&quot;:</span> [<br>&#123;<br><span class="hljs-attr">&quot;field&quot;:</span> <span class="hljs-string">&quot;pid&quot;</span><br>&#125;,<br><span class="hljs-string">...</span><br>]<br><span class="hljs-attr">&quot;sort&quot;:</span> [<br>&#123;<br><br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果格式和上面不一样了，字段是包在fields里的，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br><span class="hljs-attr">&quot;hits&quot;:</span> [<br>&#123;<br><span class="hljs-attr">&quot;_index&quot;:</span> <span class="hljs-string">xxx</span>,<br><span class="hljs-attr">&quot;_type&quot;:</span> <span class="hljs-string">xxx</span>,<br><span class="hljs-attr">&quot;fields&quot;:</span> &#123;<br><span class="hljs-attr">&quot;pid&quot;:</span> [<span class="hljs-string">xxx</span>],<br><span class="hljs-attr">&quot;level&quot;:</span> [<span class="hljs-string">xxx</span>],<br><span class="hljs-attr">&quot;_host.name&quot;:</span> [<span class="hljs-string">xxx</span>]<br>&#125;<br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>filebeat只能输出到一个地方，logstach可以输出到多个地方</p></li><li><p>fields_under_root,这个字段如果设置为true，则新增的字段成为顶级目录，和message平级，如果为false，则会多出一个fields字段，这个fields字段和message字段平级，我们自定义的字段都存放在fields字段下</p></li><li><p>注意，filebeat文件夹下有一个data的文件夹，可以记录哪些行传输过，所以如果ctrl+c之后再重开，不会把之前传过的内容再传一遍，除非删除这个data文件夹</p></li></ul><h2 id="Logstach安装以及使用"><a href="#Logstach安装以及使用" class="headerlink" title="Logstach安装以及使用"></a>Logstach安装以及使用</h2><ul><li><p>二进制安装，解压即用</p></li><li><p>可以用root用户启动</p></li><li><p>部署命令：`bin/logstash -f config/xxx.conf</p></li><li><p>测试config文件是否写的正确<code>bin/logstash -t -f config/xxx.conf</code></p></li><li><p>配置logstash自动刷新配置文件：<code>bin/logstash -f config/xxx.conf --config.reload.automatic  </code></p></li><li><p>配置文件如下：</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">input</span> &#123;<br>  beats &#123;<br>    <span class="hljs-attr">port</span> =&gt; <span class="hljs-number">5044</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">filter</span> &#123;<br>  mutate&#123;<br>    <span class="hljs-attr">rename</span> =&gt; &#123;<span class="hljs-string">&quot;host&quot;</span> =&gt; <span class="hljs-string">&quot;_host&quot;</span>&#125;<br>    <span class="hljs-keyword">rename</span> =&gt; &#123;<span class="hljs-string">&quot;message&quot;</span> =&gt; <span class="hljs-string">&quot;_message&quot;</span>&#125;<br>    rename =&gt; &#123;<span class="hljs-string">&quot;tags&quot;</span> =&gt; <span class="hljs-string">&quot;_tags&quot;</span>&#125;<br>    remove_field =&gt; [<span class="hljs-string">&quot;@version&quot;</span>, <span class="hljs-string">&quot;ecs&quot;</span>]<br>  &#125;<br>  if [log][file][path] == <span class="hljs-string">&quot;/usr/local/dashuaibi/log/wang.log&quot;</span>&#123;<br>    <span class="hljs-keyword">dissect</span> &#123;<br>      <span class="hljs-attr">mapping</span> =&gt; &#123;<br>        <span class="hljs-string">&quot;message&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;wang_time&#125; %&#123;wang_pid&#125; %&#123;wang_level&#125; %&#123;comtent&#125;&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">output</span> &#123;<br>  <span class="hljs-keyword">if</span> [log][file][<span class="hljs-built_in">path</span>] == <span class="hljs-string">&quot;/usr/local/dashuaibi/log/wang.log&quot;</span>&#123;<br>    elasticsearch &#123;<br>    <span class="hljs-attr">hosts</span> =&gt; <span class="hljs-string">&quot;10.1.1.186:9200&quot;</span><br>      <span class="hljs-attr">index</span> =&gt; <span class="hljs-string">&quot;wang_test_666&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：mapping里的分隔符表达式，最后一个字段默认会把后面所有的内容都接收下来</li><li>field字段的增删改在filebeat和logstash中都可以做，看业务需求。</li></ul></li></ul><h2 id="Elasticsearch安装以及使用"><a href="#Elasticsearch安装以及使用" class="headerlink" title="Elasticsearch安装以及使用"></a>Elasticsearch安装以及使用</h2><ul><li><p>二进制安装，解压即用<code>tar -zxf xxx.tar.gz</code></p></li><li><p>先在root用户下修改权限<code>chown -R elastic:elastic elastic</code></p><ul><li>最后一个elastic是文件夹的名字</li><li>-R表示处理指定目录以及其子目录下的所有文件</li></ul></li><li><p><code>vim config/elasticsearch.yml</code>，将<code>network.host: 0.0.0.0</code>,让外部可以访问到</p></li><li><p><code>node.name: node-1</code>这行的注释也打开，下面这个操作要用</p></li><li><p><code>vim config/elasticsearch.yml</code>，将<code>cluster.initial_master_nodes: [&quot;node-1&quot;]</code>这行的注释打开，有几个节点就在list里写几个值，否则master节点会一直搜索另一个节点，”node-1”是本台机器的hostname,需要提前在/etc/hosts里定义（如果默认没有添加的话），文件里写的是ip + hostname（需要把ES集群里的每一个节点的信息都写在这个里面）</p></li><li><p>启动命令：<code>bin/elasticsearch</code>，在后面加-d就是后台启动，如果用nohup … &amp; 启动,注意nohup.out是否会打的太多导致存储空间不够</p></li><li><p>ES不能使用root用户启动</p></li><li><p>可以在创建ES索引的时候指定分片的参数,wangtest是要创建的索引名</p></li><li><p>配置文件参考如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">cluster</span>.name: db-<span class="hljs-keyword">search</span><br>node.name: dc-<span class="hljs-keyword">search</span>-es7<span class="hljs-number">-1</span><br>node.data: <span class="hljs-keyword">true</span><br>node.master: <span class="hljs-keyword">true</span><br><span class="hljs-type">path</span>.data: /data01/elasticsearch/data<br><span class="hljs-type">path</span>.logs: /data01/elasticsearch/<span class="hljs-keyword">log</span><br>network.host: <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>http.port: <span class="hljs-number">9200</span><br>transport.tcp.port: <span class="hljs-number">9300</span><br><br>discovery.seed_hosts: [&quot;10.3.23.249:9300&quot;,&quot;10.3.23.48:9300&quot;,&quot;10.3.23.191:9300&quot;]<br><span class="hljs-keyword">cluster</span>.initial_master_nodes: [&quot;10.3.23.249:9300&quot;,&quot;10.3.23.48:9300&quot;,&quot;10.3.23.191:9300&quot;]<br># 以下内容如果不需要用x-pack可以不用配置<br>xpack.<span class="hljs-keyword">security</span>.enabled: <span class="hljs-keyword">true</span><br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.enabled: <span class="hljs-keyword">true</span><br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.verification_mode: certificate<br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.keystore.path: elastic-certificates.p12<br>xpack.<span class="hljs-keyword">security</span>.transport.ssl.truststore.path: elastic-certificates.p12<br><br></code></pre></td></tr></table></figure></li><li><p>cluster.initial_master_nodes只是初始化集群的时候会用到，discovery.seed_hosts里面的节点都是候选主节点，这个是以后主节点崩了的话会用到这里的配置</p></li><li><p>如果在配置文件里配置了5个候选主节点，一定要有大于一半数量的节点接入集群才能正常工作</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">PUT</span> <span class="hljs-string">wangtest</span><br>&#123;<br>  <span class="hljs-attr">&quot;settings&quot;:</span> &#123;<br>    <span class="hljs-attr">&quot;index&quot;:</span> &#123;<br>      <span class="hljs-attr">&quot;number_of_shards&quot;:</span> <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;number_of_replicas&quot;:</span> <span class="hljs-number">1</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Kibana安装以及使用"><a href="#Kibana安装以及使用" class="headerlink" title="Kibana安装以及使用"></a>Kibana安装以及使用</h2><ul><li>二进制安装，解压即用</li><li><code>vim config/kibana.yml</code>，将<code>server.host：&quot;0.0.0.0&quot;</code>,让外部可以访问到</li><li>启动命令：<code>./bin/kibana</code>,注意这个.必须带</li><li>Kibana也不能使用root用户启动,但是根据提示，好像有开关可以控制使用root启动</li><li>如果在kibana中console执行需要运行很长时间的代码，需要修改timeout，否则会报502，默认只等30s</li><li><code>vim config/kibana.yml</code></li><li>将<code>elasticsearch.requestTimeout: 300000</code>原本30000是ms，等于30秒</li><li>将<code>elasticsearch.shardTimeout: 300000</code>原本30000是ms，等于30秒,每个分片的最多等待时长</li></ul><h2 id="监控软件cerebro的安装和使用"><a href="#监控软件cerebro的安装和使用" class="headerlink" title="监控软件cerebro的安装和使用"></a>监控软件cerebro的安装和使用</h2><ul><li><p>下载压缩包，解压</p></li><li><p>bin/cerebro</p></li><li><p>非必须：如果经常使用的话，可以先在<code>conf/application.conf</code>中配置好ElasticSearch服务器地址</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">hosts</span> = [<br>  &#123;<br>    <span class="hljs-attr">host</span> = <span class="hljs-string">&quot;http://localhost:9200&quot;</span><br>    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;Some Cluster&quot;</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure></li><li><p>参考：<a href="https://www.jianshu.com/p/433d821f9667">https://www.jianshu.com/p/433d821f9667</a></p></li></ul><h2 id="如何在脚本里启动filebeat"><a href="#如何在脚本里启动filebeat" class="headerlink" title="如何在脚本里启动filebeat"></a>如何在脚本里启动filebeat</h2><ul><li><p>前提背景：有一些场景是需要在脚本里自动启动的 ，且希望在后台运行，所以我想到了nohup</p><p><code>nohup ./filebeat -e -c /usr/local/sahoc/filebeat.yml &amp;</code></p><p>这个做法可以后台起一个进程运行filebeat，但是主进程不会退出，<strong>因为启动的filebeat在另一个进程里有终端输出</strong></p></li><li><p>解决方案：<code>nohup ./filebeat -e -c /usr/local/sahoc/filebeat.yml &gt;&gt; $FILEBEAT_LOG 2&gt;&amp;1 &amp;</code></p><p>这样把终端的输出重定向到一个文件，主进程就不会持续监听了，注意2&gt;&amp;1必须加，必须把所有的输出都追加到文件，文件地址可以是/dev/null</p></li></ul><h3 id="关于ES查询的分页问题"><a href="#关于ES查询的分页问题" class="headerlink" title="关于ES查询的分页问题"></a>关于ES查询的分页问题</h3><p>这里的查询分为两种，一种是基于ES的DQL，就是用restfulAPI的调用方式，另一种是说使用SQL语言进行查询。众所周知在MYSQL里分页可以使用limit 10,5来解决，第一个10是偏移量（offset），从第十个数据开始读取，第二个参数5说明是一次取5个值，通过这种方式可以实现分页。但是使用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">POST /_sql?<span class="hljs-attribute">format</span>=txt&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;SELECT CONTENT FROM XXX LIMIT 10,5&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ES报错，不能识别逗号，所以说这个接口里的limit后面只支持一个参数。下面说分别对应这两种方法的解决方案</p><ul><li><p>DQL查询方式</p><ul><li>from+size方式</li><li>scroll方式</li><li>search_after方式</li><li>参考：<a href="https://chunsoft.blog.csdn.net/article/details/91406928">https://chunsoft.blog.csdn.net/article/details/91406928</a></li></ul></li><li><p>SQL的查询方式</p><ul><li>cursor（游标）方式</li><li>参考：<a href="https://blog.csdn.net/qq_42569136/article/details/115465322">https://blog.csdn.net/qq_42569136/article/details/115465322</a></li><li>参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-pagination.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-pagination.html</a></li><li>感觉这种方式和上面的search_after是一样的，多用于数据导出，并不适用这种场景，且不能跳转，只能一页一页的读</li><li>fetch_size方案</li><li>参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-search-api.html#sql-search-api-request-body">https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-search-api.html#sql-search-api-request-body</a></li><li>可以看到这里有一个fetch_size的参数，讲道理应该和上面一样还有一个fetch_from就完美了，可惜是官方并没有提供这个参数，想不明白是为什么</li></ul></li><li><p>最终的方案，使用先用/_sql/translate把SQL查询变成DQL之后，再在DQL里面补充from和size字段，默认情况下使用translate会自动有一个size:1000的对象，如果SQL语句里有limit 100，这个1000就变成100了，但是不会自动添加from</p></li></ul><h3 id="如果一行数据，用指定的分割方式没有分割出来怎么办"><a href="#如果一行数据，用指定的分割方式没有分割出来怎么办" class="headerlink" title="如果一行数据，用指定的分割方式没有分割出来怎么办"></a>如果一行数据，用指定的分割方式没有分割出来怎么办</h3><p>直接把这个数据添加到message里，并不会丢弃</p><h3 id="如果之前我们的filebeat的input-yml文件有一段时间为空，后面再加上还能正常工作吗？"><a href="#如果之前我们的filebeat的input-yml文件有一段时间为空，后面再加上还能正常工作吗？" class="headerlink" title="如果之前我们的filebeat的input.yml文件有一段时间为空，后面再加上还能正常工作吗？"></a>如果之前我们的filebeat的input.yml文件有一段时间为空，后面再加上还能正常工作吗？</h3><p>可以</p><h3 id="采用上面的方案会导致，每次有新的数据加入log文件，都会把之前的所有内容再重新传一遍，导致重复采集"><a href="#采用上面的方案会导致，每次有新的数据加入log文件，都会把之前的所有内容再重新传一遍，导致重复采集" class="headerlink" title="采用上面的方案会导致，每次有新的数据加入log文件，都会把之前的所有内容再重新传一遍，导致重复采集"></a>采用上面的方案会导致，每次有新的数据加入log文件，都会把之前的所有内容再重新传一遍，导致重复采集</h3><ul><li>问题出在vim编辑器，用echo添加就不会有问题，估计是vim保存的时候创建了一个新的文件或者链接</li><li>参考：<a href="https://elasticsearch.cn/question/2533">https://elasticsearch.cn/question/2533</a></li></ul><blockquote><p>vi指令保存后,会重复发送,用echo写东西测试没问题，类似vi估计都会有问题。官方论坛翻译内容如下：</p><p>你怎么修改文件。你试过了$ echo ‘new line’ &gt;&gt; /usr/src/app/log.log吗？filebeat试图根据元数据来检测文件是否是新的。一些工具/编辑器创建一个全新的文件保存并取消旧链接。这被filebeat检测为新文件，迫使它重新发送所有内容。</p></blockquote><h3 id="上面使用-log-file-path-不太严谨"><a href="#上面使用-log-file-path-不太严谨" class="headerlink" title="上面使用[log][file][path]不太严谨"></a>上面使用<code>[log][file][path]</code>不太严谨</h3><ul><li><p>如果不同机器上有不同的业务，但是log文件名都一样，这样就会把这些日志放在一个索引，其实不应该放在一起</p></li><li><p>采用打tags的方式解决</p></li><li><p>filebeat_input.yml文件里加入tag</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">log</span><br><br>  <span class="hljs-comment"># Change to true to enable this input configuration.</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># Paths that should be crawled and fetched. Glob based paths.</span><br>  <span class="hljs-attr">paths:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/xxx</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">wang1</span><br>  <span class="hljs-attr">fields:</span> <br>    <span class="hljs-attr">source:</span> <span class="hljs-string">wang_test</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">log</span><br><br>  <span class="hljs-comment"># Change to true to enable this input configuration.</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># Paths that should be crawled and fetched. Glob based paths.</span><br>  <span class="hljs-attr">paths:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/xxx</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">wang2</span><br>  <span class="hljs-attr">fields:</span> <br>    <span class="hljs-attr">source:</span> <span class="hljs-string">wang_test</span><br></code></pre></td></tr></table></figure><p>tags后面的值可以不带引号</p></li><li><p>logstash配置文件根据这个tag去做相应的处理</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">inputs</span> &#123;<br>  beats &#123;<br>    <span class="hljs-attr">port</span> =&gt; <span class="hljs-number">5044</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">filter</span> &#123;<br>  <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;wang1&quot;</span> <span class="hljs-keyword">in</span> [tags]&#123;<br>    dissect &#123;<br>      <span class="hljs-attr">mapping</span> =&gt; &#123;<br>        <span class="hljs-string">&quot;message&quot;</span> =&gt; <span class="hljs-string">&quot;%&#123;wang_time&#125; %&#123;wang_pid&#125; %&#123;wang_level&#125; %&#123;comtent&#125;&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">output</span> &#123;<br>  <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;wang1&quot;</span> <span class="hljs-keyword">in</span> [tags]&#123;<br>    elasticsearch &#123;<br>      <span class="hljs-attr">hosts</span> =&gt; <span class="hljs-string">&quot;10.1.1.186:9200&quot;</span><br>      <span class="hljs-attr">index</span> =&gt; <span class="hljs-string">&quot;wang_test_666&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3高并发定时更新任务进程池和线程池的使用</title>
    <link href="/2021/08/01/Python3%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/08/01/Python3%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Python3高并发定时更新任务进程池和线程池的使用"><a href="#Python3高并发定时更新任务进程池和线程池的使用" class="headerlink" title="Python3高并发定时更新任务进程池和线程池的使用"></a>Python3高并发定时更新任务进程池和线程池的使用</h2><ul><li>背景：需要定时对数据库的某一张表做更新</li><li>不管用多线程还是多进程只能利用当前一台机器的计算能力，可以考虑使用celery这样的工具，后期可以横向扩展celery的执行机，也不用考虑生产者消费者模型，celery里面自动都帮我们处理好了，也有消息队列的机制，我们只负责往里面丢任务即可</li></ul><h2 id="Django中connections-close-all-的作用"><a href="#Django中connections-close-all-的作用" class="headerlink" title="Django中connections.close_all()的作用"></a>Django中connections.close_all()的作用</h2><ul><li>我们链接到mysql的时候，会创建一个链接，这个链接一般都有一个有效期，当新起一个进程的时候会fork父进程里的数据库链接文件，但是这些链接文件可能马上就失效了，万一在我们子进程的任务中突然有一个链接失效就会报错，所以在新起子进程的时候先执行一下这个命令，关闭旧链接，后面用了再创建自己的新链接即可</li><li>数据库链接超时的报错不光有mysql gone away，还有各种游标报错，None类型报错等，都可能是由于链接超时或者错误关闭链接导致</li><li>如果在子进程里使用了多进程，就会fork出好多链接文件，一不小心就会关闭还需要使用的链接，就会报错，建议传参的时候都穿hash_key，在子进程里再重新查询获取这个对象，这样这个对象的生命周期就可以自己掌控了</li><li>但是创建多线程的时候不存在fork，基本不会有断联的情况</li></ul><h3 id="进程池的使用"><a href="#进程池的使用" class="headerlink" title="进程池的使用"></a>进程池的使用</h3><p>参考：<a href="https://www.cnblogs.com/kaituorensheng/p/4465768.html">https://www.cnblogs.com/kaituorensheng/p/4465768.html</a></p><p>这个虽然使用的是Python2，但是给的例子里除了print加括号以外，都是可以正常使用的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">#coding: utf<span class="hljs-number">-8</span><br><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">import</span> time<br><br>def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(msg)</span>:</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;msg:&quot;</span>, msg)<br>    time.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    pool = multiprocessing.Pool(processes = <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> i in xrange(<span class="hljs-number">4</span>):<br>        msg = <span class="hljs-string">&quot;hello %d&quot;</span> %(i)<br>        pool.apply_async(<span class="hljs-function"><span class="hljs-keyword">func</span>, <span class="hljs-params">(msg, )</span>)   #维持执行的进程总数为<span class="hljs-title">processes</span>，当一个进程执行完毕后会添加新的进程进去</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mark~ Mark~ Mark~~~~~~~~~~~~~~~~~~~~~~&quot;</span>)<br>    pool.<span class="hljs-built_in">close</span>()<br>    pool.join()   #调用join之前，先调用<span class="hljs-built_in">close</span>函数，否则会出错。执行完<span class="hljs-built_in">close</span>后不会有新的进程加入到pool,join函数等待所有子进程结束<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sub-process(es) done.&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>参考：<a href="https://www.jianshu.com/p/b9b3d66aa0be">https://www.jianshu.com/p/b9b3d66aa0be</a></p><ul><li>注意：进程池创建进程的时候，里面第二个参数是元祖，而创建线程池的时候，里面第二个参数就是普通的参数</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多进程问题，以及如何避免僵尸进程</title>
    <link href="/2021/07/01/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/07/01/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="接上一篇Ansible和celery的结合，在celery的tasks-py文件里为了实现并发不阻塞的需求，用到了多进程"><a href="#接上一篇Ansible和celery的结合，在celery的tasks-py文件里为了实现并发不阻塞的需求，用到了多进程" class="headerlink" title="接上一篇Ansible和celery的结合，在celery的tasks.py文件里为了实现并发不阻塞的需求，用到了多进程"></a>接上一篇Ansible和celery的结合，在celery的tasks.py文件里为了实现并发不阻塞的需求，用到了多进程</h2><p>举例如下：tasks.py文件如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> signal<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> connections<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close_old_connecttions</span>():</span><br>    connections.close_all()<br><br><span class="hljs-meta">@shared_task</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span>():</span><br>    signal.signal(signal.SIGCHLD, signal.SIG_IGN)<br>    close_old_connections():<br>    process = Process(<br>    target=_function,<br>    args=(x,x,x)<br>    )<br>    process.start()<br>    <span class="hljs-comment"># process.join()</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_function</span>():</span><br>    xxx<br>    <span class="hljs-keyword">return</span> Ture<br><br></code></pre></td></tr></table></figure><h3 id="先说为什么重新开子进程"><a href="#先说为什么重新开子进程" class="headerlink" title="先说为什么重新开子进程"></a>先说为什么重新开子进程</h3><ul><li>function函数是执行在celery起的主进程里的，一般-n 是4，就是有4个进程，能同时处理4个请求，如果同时有10个请求，且，每一个任务都要执行十分钟，那么就会产生阻塞，重新起子进程的过程可能只需要几秒，就不会产生阻塞，前提是不加join</li></ul><h3 id="解释signal那一行"><a href="#解释signal那一行" class="headerlink" title="解释signal那一行"></a>解释signal那一行</h3><ul><li>signal.signal中的第一个参数是要监听的状态，signal.SIGCHLD为子进程死亡或退出，第二个参数是监听到前面的状态时采用的处理操作，signal.SIG_IGN的意思是什么都不做。</li><li>这个什么也不做并不是正真的什么也不做，如果没有这一行，系统判定父进程没有定义子进程退出的处理函数，就是僵尸进程，但是如果定义了就算这个操作是什么都不做，系统也知道父进程定义了，就不会产生僵尸进程</li></ul><h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h3><ul><li>子进程退出，系统会回收内存空间，但是会留下pcb控制块，里面会有一些PID信息和退出信息，如果父进程没有回收执行完毕的子进程，就会产生僵尸进程，产生资源浪费</li><li>孤儿进程是父进程先于子进程退出了，这是子进程会是孤儿进程，由init进程负责回收（<strong>孤儿进程无害</strong>）</li></ul><h3 id="两种避免僵尸进程产生的方法：两次fork方法和signal信号方法"><a href="#两种避免僵尸进程产生的方法：两次fork方法和signal信号方法" class="headerlink" title="两种避免僵尸进程产生的方法：两次fork方法和signal信号方法"></a>两种避免僵尸进程产生的方法：两次fork方法和signal信号方法</h3><ul><li><p>参考：<a href="https://yhyr.github.io/2018/06/06/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E4%BA%8C/">https://yhyr.github.io/2018/06/06/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E4%BA%8C/</a></p></li><li><p>但是signal的方法设置感觉会对子进程后面再起的孙子进程也生效，但是如果我们在process中调用ansible的模块，一个playbook会产生很多子进程，这个相较于之前的父进程，现在其实是孙子进程了。ansible里可能会自己定义handler函数，如果用signal方式就会覆盖ansible的自定义函数，导致孙子进程只能起来一个，后面的步骤就不会执行了。因此如果使用ansible的话推荐使用两次fork的方式代码如下：</p></li><li><pre><code class="python">import signalfrom multiprocessing import Processfrom django.db import connectionsdef close_old_connecttions():    connections.close_all()@shared_taskdef function():    signal.signal(signal.SIGCHLD, signal.SIG_IGN)    close_old_connections():    process = Process(        target=_excutor,        args=(x,x,x)    )    process.start()    process.join() # 这个必须加def _excutor():    process = Process(        target=_function,        args=(x,x,x)    )    process.start()    def _function():    xxx    return Ture</code></pre></li><li><p>如果百度过此类问题的不难发现，网上有很多说可以通过fork两次来避免僵尸进程。其实这是一个很不错的方法，也是一个比较容易理解的。只是关于该方法的解释不是很多(可能因为笔者太low，对于很多人来说都是一看就懂的^v^)，在这里我将就该方法做以详细的解释和说明，希望对刚接触此类问题的小伙伴们有所帮助。</p><p>　　首先需要注意的是fork函数是unix/linux系统上特有的，在Windows上运行该函数会直接报错，而通过都是用Windows机器做开发，在Linux上跑代码的这种，直接在Linux上写代码又是比较麻烦的(如果愿意可以基于VM搭建一个桌面版的CentOS，然后装个编译器来开发)，所以这里笔者从一开始就选择Python提供的一种跨平台的多进程模块 – multiprocessing来实现多进程(其实multiprocessing中基于Linux的代码实现逻辑就是fork，对于该模块源码初探可详见<a href="https://yhyr.github.io/2018/06/07/%E5%9F%BA%E4%BA%8EPython%E5%88%9D%E6%8E%A2Linux%E4%B8%8B%E7%9A%84%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E4%B8%89/">传送门</a>)。</p><p>　　如何理解fork两次即可达到我们想要的想过呢？此处假设我们的业务场景是父进程一直存在，而子进程的执行周期短，且执行完后就退出。我们知道，当主进程创建一个子进程时，此时子进程的ppid即就是父进程的pid；而子进程结束后如果父进程没有获取子进程的退出状态信息，则子进程会变成僵尸进程；我们又知道，如果一个子进程是孤儿进程的话，那么它就是安全可靠的(不会产生僵尸进程)；所以基于以上原因，可以进行如下设计：主进程的业务逻辑保持不变，只是在主进程创建子进程的时候，不直接创建子进程去执行相应的业务逻辑；而是创建一个单独进程(此处理解为爸爸进程)，该进程只干一件事，就是创建原本应该有父进程创建的子进程。即就是将原本的“主进程 =&gt; 儿子进程”修改为“主进程 =&gt; 爸爸进程 =&gt; 儿子进程”，这种设计里只有主进程和儿子进程是需要关注的，而爸爸进程逻辑很简单，就是初始化儿子进程；所以当爸爸进程结束后儿子进程就沦为孤儿进程了，这样无论儿子进程执行多久，都不会产生僵尸进程。</p><p>　　有人就会想，爸爸进程退出不也会产生僵尸进程吗？其实这个问题很好解决，利用上述中的不带参数的join()方法即可解决。可以在主进程中创建父进程的同时，添加p.join()方法，因为爸爸进程创建儿子进程的耗时很短，所以可以在主进程创建爸爸进程的时候使用p.join()挂起，这个时间差是可以忽略和接受的，这样当父进程创建完儿子进程后父进程就会立马结束，此时主进程就会执行p.join()方法获取到爸爸进程的退出信息，从而彻底消除爸爸进程；这样进程列表里就只剩下一个主进程和一个而孤儿进程(原本的儿子进程转化而来)；这样就实现了真正意义上的并发。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux、多进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在python中使用Ansible实现Devops的相关总结</title>
    <link href="/2021/06/06/%E5%9C%A8python%E4%B8%AD%E4%BD%BF%E7%94%A8Ansible%E5%AE%9E%E7%8E%B0Devops%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <url>/2021/06/06/%E5%9C%A8python%E4%B8%AD%E4%BD%BF%E7%94%A8Ansible%E5%AE%9E%E7%8E%B0Devops%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="在python中使用Ansible实现Devops的相关总结"><a href="#在python中使用Ansible实现Devops的相关总结" class="headerlink" title="在python中使用Ansible实现Devops的相关总结"></a>在python中使用Ansible实现Devops的相关总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    Ansible虽然底层是用python写的，但是对python的API支持并不友好，官方文档里只用了一个example来说明，想知道各个组件的参数功能可能只能去看源码了，现在记录一下自己的总结</p><h3 id="环境——ansible-2-8-1"><a href="#环境——ansible-2-8-1" class="headerlink" title="环境——ansible==2.8.1"></a>环境——ansible==2.8.1</h3><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ul><li><p>如果需要有额外的参数，或者在playbook中需要传入参数怎么办？</p><p>在context.CLIARGS = ImmutableDict中通过extra_vars=[extra_vars]的方式</p></li><li><p>ansible.cfg文件应该放在哪里？</p><p>ansible.cfg这个文件pip install后并不会自动在/etc/ansible中创建，需要去github中将里面的example文件夹下的文件拷贝进本地才行。优先级问题：这个文件如果需要跟着项目走，那么在哪里执行run脚本文件，这个ansible.cfg文件就应该放在哪里。如果在这里找不到就去/etc/ansible里找，当然也可以设置环境变量，这个优先级最高</p></li><li><p>如果playbook一个命令执行时间太长怎么办？</p><p>ssh链接最长好像只有5分钟，5分钟后还没执行完，直接返回unreachable。我尝试在代码中添加constant，或者修改ansible.cfg里的各种timeout，或者retries都不管用，最后是通过在playbook中加入async解决的</p><p>例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-number">666</span><br>  <span class="hljs-attr">hosts:</span> <span class="hljs-string">&quot;666&quot;</span><br>  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">no</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-number">6</span><span class="hljs-string">不6</span><br>      <span class="hljs-attr">shell:</span><br>        <span class="hljs-attr">chdir:</span> <span class="hljs-string">/root</span><br>        <span class="hljs-attr">cmd:</span> <span class="hljs-string">ls</span><br>      <span class="hljs-attr">async:</span> <span class="hljs-number">1200</span><br>      <span class="hljs-attr">poll:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ul><li>poll的意思是说每隔10秒重新连接一次，只要poll大于0，就是阻塞状态，直到这个异步任务执行结束才会执行下一个task。如果设置poll=0，就会即可跳过这个task（转到后台执行），继续执行下面的任务，使用于两种不同的场景，详情见官方手册</li></ul><p>参考：</p><p><a href="https://stackoverflow.com/questions/41455002/long-running-command-in-ansible-ending-in-failed-status-with-host-unreachable">https://stackoverflow.com/questions/41455002/long-running-command-in-ansible-ending-in-failed-status-with-host-unreachable</a></p><p><a href="https://www.axelerant.com/resources/team-blog/how-handle-long-running-tasks-ansible">https://www.axelerant.com/resources/team-blog/how-handle-long-running-tasks-ansible</a></p></li><li><p>关于callback函数的改写</p><p>callback函数是说每次有一个task任务被执行，会根据执行的状态success，failed等等去调用这些函数，result就是执行中调用这个函数时的入参，通过下面的例子的方式可以保存下来这些内容</p></li></ul><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">from</span> ansible <span class="hljs-keyword">import</span> constants<br><span class="hljs-keyword">from</span> ansible.executor.playbook_executor <span class="hljs-keyword">import</span> PlaybookExecutor<br><span class="hljs-keyword">from</span> ansible.module_utils.common.collections <span class="hljs-keyword">import</span> ImmutableDict<br><span class="hljs-keyword">from</span> ansible.parsing.dataloader <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> ansible.<span class="hljs-built_in">vars</span>.manager <span class="hljs-keyword">import</span> VariableManager<br><span class="hljs-keyword">from</span> ansible.inventory.manager <span class="hljs-keyword">import</span> InventoryManager<br><span class="hljs-keyword">from</span> ansible.playbook.play <span class="hljs-keyword">import</span> Play<br><span class="hljs-keyword">from</span> ansible.inventory.group <span class="hljs-keyword">import</span> Group<br><span class="hljs-keyword">from</span> ansible.inventory.host <span class="hljs-keyword">import</span> Host<br><span class="hljs-keyword">from</span> ansible.executor.task_queue_manager <span class="hljs-keyword">import</span> TaskQueueManager<br><span class="hljs-keyword">from</span> ansible.plugins.callback <span class="hljs-keyword">import</span> CallbackBase<br><span class="hljs-keyword">from</span> ansible <span class="hljs-keyword">import</span> context<br><span class="hljs-keyword">import</span> ansible.constants <span class="hljs-keyword">as</span> C<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResultCallback</span>(<span class="hljs-params">CallbackBase</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    重写callbackBase类的部分方法</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)<br>        self.task_ok = []<br>        self.task_unreachable = []<br>        self.task_failed = []<br>        self.task_skipped = []<br>        self.task_status = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">v2_runner_on_ok</span>(<span class="hljs-params">self, result, **kwargs</span>):</span><br>        self.task_ok.append(&#123;result._host.get_name(): result&#125;)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">v2_runner_on_failed</span>(<span class="hljs-params">self, result, **kwargs</span>):</span><br>        self.task_failed.append(&#123;result._host.get_name(): result&#125;)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">v2_runner_on_skipped</span>(<span class="hljs-params">self, result, **kwargs</span>):</span><br>        self.task_skipped.append(&#123;result._host.get_name(): result&#125;)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">v2_runner_on_unreachable</span>(<span class="hljs-params">self, result, **kwargs</span>):</span><br>        self.task_unreachable.append(&#123;result._host.get_name(): result&#125;)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">v2_playbook_on_stats</span>(<span class="hljs-params">self, stats</span>):</span><br>        hosts = <span class="hljs-built_in">sorted</span>(stats.processed.keys())<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> hosts:<br>            t = stats.summarize(h)<br>            self.task_status[h] = &#123;<br>                <span class="hljs-string">&quot;ok&quot;</span>: t[<span class="hljs-string">&quot;ok&quot;</span>],<br>                <span class="hljs-string">&quot;changed&quot;</span>: t[<span class="hljs-string">&quot;changed&quot;</span>],<br>                <span class="hljs-string">&quot;unreachable&quot;</span>: t[<span class="hljs-string">&quot;unreachable&quot;</span>],<br>                <span class="hljs-string">&quot;skipped&quot;</span>: t[<span class="hljs-string">&quot;skipped&quot;</span>],<br>                <span class="hljs-string">&quot;failed&quot;</span>: t[<span class="hljs-string">&quot;failed&quot;</span>]<br>            &#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInventory</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, hostsresource</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        初始化函数</span><br><span class="hljs-string">        :param hostsresource: 主机资源可以有2种形式</span><br><span class="hljs-string">        列表形式: [&#123;&quot;ip&quot;: &quot;172.16.48.171&quot;, &quot;port&quot;: &quot;22&quot;, &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot;&#125;]</span><br><span class="hljs-string">        字典形式: &#123;</span><br><span class="hljs-string">                    &quot;Group1&quot;: &#123;</span><br><span class="hljs-string">                        &quot;hosts&quot;: [&#123;&quot;ip&quot;: &quot;192.168.200.10&quot;, &quot;port&quot;: &quot;1314&quot;, &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: None&#125;],</span><br><span class="hljs-string">                        &quot;vars&quot;: &#123;&quot;var1&quot;: &quot;ansible&quot;&#125;</span><br><span class="hljs-string">                    &#125;,</span><br><span class="hljs-string">                    &quot;Group2&quot;: &#123;&#125;</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self._hostsresource = hostsresource<br>        self._loader = DataLoader()<br>        self._hostsfilelist = [<span class="hljs-string">&quot;temphosts&quot;</span>]<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        sources这个我们知道这里是设置hosts文件的地方，它可以是一个列表里面包含多个文件路径且文件真实存在，在单纯的执行ad-hoc的时候这里的</span><br><span class="hljs-string">        文件里面必须具有有效的hosts配置，但是当通过动态生成的资产信息的时候这个文件必须存在但是它里面可以是空的，如果这里配置成None那么</span><br><span class="hljs-string">        它不影响资产信息动态生成但是会有一个警告，所以还是要配置一个真实文件。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self._inventory = InventoryManager(loader=self._loader, sources=self._hostsfilelist)<br>        self._variable_manager = VariableManager(loader=self._loader, inventory=self._inventory)<br><br>        self._dynamic_inventory()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_dynamic_group</span>(<span class="hljs-params">self, hosts_list, groupname, groupvars=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        动态添加主机到指定的主机组</span><br><span class="hljs-string"></span><br><span class="hljs-string">        完整的HOSTS文件格式</span><br><span class="hljs-string">        [test1]</span><br><span class="hljs-string">        hostname ansible_ssh_host=192.168.1.111 ansible_ssh_user=&quot;root&quot; ansible_ssh_pass=&quot;123456&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        但通常我们都省略hostname，端口也省略因为默认是22，这个在ansible配置文件中有，除非有非22端口的才会配置</span><br><span class="hljs-string">        [test1]</span><br><span class="hljs-string">        192.168.100.10 ansible_ssh_user=&quot;root&quot; ansible_ssh_pass=&quot;123456&quot; ansible_python_interpreter=&quot;/PATH/python3/bin/python3&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param hosts_list: 主机列表 [&#123;&quot;ip&quot;: &quot;192.168.100.10&quot;, &quot;port&quot;: &quot;22&quot;, &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: None&#125;, &#123;&#125;]</span><br><span class="hljs-string">        :param groupname:  组名称</span><br><span class="hljs-string">        :param groupvars:  组变量，格式为字典</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 添加组</span><br>        my_group = Group(name=groupname)<br>        self._inventory.add_group(groupname)<br><br>        <span class="hljs-comment"># 添加组变量</span><br>        <span class="hljs-keyword">if</span> groupvars:<br>            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> groupvars.items():<br>                my_group.set_variable(key, value)<br><br>        <span class="hljs-comment"># 添加一个主机</span><br>        <span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> hosts_list:<br>            hostname = host.get(<span class="hljs-string">&quot;hostname&quot;</span>, <span class="hljs-literal">None</span>)<br>            hostip = host.get(<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> hostip <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IP地址为空，跳过该元素。&quot;</span>)<br>                <span class="hljs-keyword">continue</span><br>            hostport = host.get(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>)<br>            username = host.get(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>)<br>            password = host.get(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-literal">None</span>)<br>            ssh_key = host.get(<span class="hljs-string">&quot;ssh_key&quot;</span>, <span class="hljs-literal">None</span>)<br>            python_interpreter = host.get(<span class="hljs-string">&quot;python_interpreter&quot;</span>, <span class="hljs-literal">None</span>)<br><br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># hostname可以不写，如果为空默认就是IP地址</span><br>                <span class="hljs-keyword">if</span> hostname <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    hostname = hostip<br>                <span class="hljs-comment"># 生成一个host对象</span><br>                my_host = Host(name=hostname, port=hostport)<br>                <span class="hljs-comment"># 添加主机变量</span><br>                self._variable_manager.set_host_variable(host=my_host, varname=<span class="hljs-string">&quot;ansible_ssh_host&quot;</span>, value=hostip)<br>                self._variable_manager.set_host_variable(host=my_host, varname=<span class="hljs-string">&quot;ansible_ssh_port&quot;</span>, value=hostport)<br>                <span class="hljs-keyword">if</span> password:<br>                    self._variable_manager.set_host_variable(host=my_host, varname=<span class="hljs-string">&quot;ansible_ssh_pass&quot;</span>, value=password)<br>                self._variable_manager.set_host_variable(host=my_host, varname=<span class="hljs-string">&quot;ansible_ssh_user&quot;</span>, value=username)<br>                <span class="hljs-keyword">if</span> ssh_key:<br>                    self._variable_manager.set_host_variable(host=my_host, varname=<span class="hljs-string">&quot;ansible_ssh_private_key_file&quot;</span>, value=ssh_key)<br>                <span class="hljs-keyword">if</span> python_interpreter:<br>                    self._variable_manager.set_host_variable(host=my_host, varname=<span class="hljs-string">&quot;ansible_python_interpreter&quot;</span>, value=python_interpreter)<br><br>                <span class="hljs-comment"># 添加其他变量</span><br>                <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> host.items():<br>                    <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-string">&quot;hostname&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ssh_key&quot;</span>, <span class="hljs-string">&quot;python_interpreter&quot;</span>]:<br>                        self._variable_manager.set_host_variable(host=my_host, varname=key, value=value)<br><br>                <span class="hljs-comment"># 添加主机到组</span><br>                self._inventory.add_host(host=hostname, group=groupname, port=hostport)<br><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:<br>                <span class="hljs-built_in">print</span>(err)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_dynamic_inventory</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        添加 hosts 到inventory</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(self._hostsresource, <span class="hljs-built_in">list</span>):<br>            self._add_dynamic_group(self._hostsresource, <span class="hljs-string">&quot;default_group&quot;</span>)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(self._hostsresource, <span class="hljs-built_in">dict</span>):<br>            <span class="hljs-keyword">for</span> groupname, hosts_and_vars <span class="hljs-keyword">in</span> self._hostsresource.items():<br>                self._add_dynamic_group(hosts_and_vars.get(<span class="hljs-string">&quot;hosts&quot;</span>), groupname, hosts_and_vars.get(<span class="hljs-string">&quot;vars&quot;</span>))<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">INVENTORY</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        返回资产实例</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self._inventory<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VARIABLE_MANAGER</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        返回变量管理器实例</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self._variable_manager<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnsiable</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-function"><span class="hljs-params">                 hostsresource=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 connection=<span class="hljs-string">&#x27;smart&#x27;</span>,  <span class="hljs-comment"># 连接方式 local 本地方式，smart ssh方式</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 remote_user=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># ssh 用户</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 remote_password=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># ssh 用户的密码，应该是一个字典, key 必须是 conn_pass</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 private_key_file=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># 指定自定义的私钥地址</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 sudo=<span class="hljs-literal">None</span>, sudo_user=<span class="hljs-literal">None</span>, ask_sudo_pass=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 module_path=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># 模块路径，可以指定一个自定义模块的路径</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 become=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># 是否提权</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 become_method=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># 提权方式 默认 sudo 可以是 su</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 become_user=<span class="hljs-literal">None</span>,  <span class="hljs-comment"># 提权后，要成为的用户，并非登录用户</span></span></span><br><span class="hljs-function"><span class="hljs-params">                 check=<span class="hljs-literal">False</span>, diff=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 listhosts=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 listtasks=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 listtags=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 verbosity=<span class="hljs-number">3</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 forks=<span class="hljs-number">5</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 syntax=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 start_at_task=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 inventory=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 extra_vars=<span class="hljs-literal">None</span></span>):</span><br><br>        <span class="hljs-comment"># 函数文档注释</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        初始化函数，定义的默认的选项值，</span><br><span class="hljs-string">        在初始化的时候可以传参，以便覆盖默认选项的值</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        context.CLIARGS = ImmutableDict(<br>            connection=connection,<br>            remote_user=remote_user,<br>            private_key_file=private_key_file,<br>            sudo=sudo,<br>            sudo_user=sudo_user,<br>            ask_sudo_pass=ask_sudo_pass,<br>            module_path=module_path,<br>            become=become,<br>            forks=forks,<br>            become_method=become_method,<br>            become_user=become_user,<br>            verbosity=verbosity,<br>            listhosts=listhosts,<br>            listtasks=listtasks,<br>            listtags=listtags,<br>            syntax=syntax,<br>            start_at_task=start_at_task,<br>            check=<span class="hljs-literal">False</span>,<br>            extra_vars=[extra_vars]  <span class="hljs-comment"># 如果有附加参数，或者playbook中需要传入参数，可以使用这个功能</span><br>        )<br><br>        <span class="hljs-comment"># 三元表达式，假如没有传递 inventory, 就使用 &quot;localhost,&quot;</span><br>        <span class="hljs-comment"># 指定 inventory 文件</span><br>        <span class="hljs-comment"># inventory 的值可以是一个 资产清单文件</span><br>        <span class="hljs-comment"># 也可以是一个包含主机的元组，这个仅仅适用于测试</span><br>        <span class="hljs-comment">#  比如 ： 1.1.1.1,    # 如果只有一个 IP 最后必须有英文的逗号</span><br>        <span class="hljs-comment">#  或者： 1.1.1.1, 2.2.2.2</span><br><br>        my_inventory = MyInventory(hostsresource=hostsresource)<br>        <span class="hljs-comment"># 实例化数据解析器</span><br>        self.loader = DataLoader()<br><br>        <span class="hljs-comment"># 实例化 资产配置对象</span><br>        self.inv_obj = my_inventory.INVENTORY<br><br>        <span class="hljs-comment"># 设置密码</span><br>        self.passwords = remote_password<br><br>        <span class="hljs-comment"># 实例化回调插件对象</span><br>        self.results_callback = ResultCallback()<br><br>        <span class="hljs-comment"># 变量管理器</span><br>        self.variable_manager = my_inventory.VARIABLE_MANAGER<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, hosts=<span class="hljs-string">&#x27;localhost&#x27;</span>, gether_facts=<span class="hljs-string">&quot;no&quot;</span>, module=<span class="hljs-string">&quot;ping&quot;</span>, args=<span class="hljs-string">&#x27;&#x27;</span>, task_time=<span class="hljs-number">0</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        参数说明：</span><br><span class="hljs-string">        task_time -- 执行异步任务时等待的秒数，这个需要大于 0 ，等于 0 的时候不支持异步（默认值）。这个值应该等于执行任务实际耗时时间为好</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        play_source = <span class="hljs-built_in">dict</span>(<br>            name=<span class="hljs-string">&quot;Ad-hoc&quot;</span>,<br>            hosts=hosts,<br>            gather_facts=gether_facts,<br>            tasks=[<br>                <span class="hljs-comment"># 这里每个 task 就是这个列表中的一个元素，格式是嵌套的字典</span><br>                <span class="hljs-comment"># 也可以作为参数传递过来，这里就简单化了。</span><br>                &#123;<span class="hljs-string">&quot;action&quot;</span>: &#123;<span class="hljs-string">&quot;module&quot;</span>: module, <span class="hljs-string">&quot;args&quot;</span>: args&#125;, <span class="hljs-string">&quot;async&quot;</span>: task_time, <span class="hljs-string">&quot;poll&quot;</span>: <span class="hljs-number">0</span>&#125;])<br><br>        play = Play().load(play_source, variable_manager=self.variable_manager, loader=self.loader)<br><br>        tqm = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">try</span>:<br>            tqm = TaskQueueManager(<br>                inventory=self.inv_obj,<br>                variable_manager=self.variable_manager,<br>                loader=self.loader,<br>                passwords=self.passwords,<br>                stdout_callback=self.results_callback)<br><br>            result = tqm.run(play)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-keyword">if</span> tqm <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                tqm.cleanup()<br>            shutil.rmtree(C.DEFAULT_LOCAL_TMP, <span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">playbook</span>(<span class="hljs-params">self, playbooks</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Keyword arguments:</span><br><span class="hljs-string">        playbooks --  需要是一个列表类型</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            playbook = PlaybookExecutor(playbooks=playbooks,<br>                                        inventory=self.inv_obj,<br>                                        variable_manager=self.variable_manager,<br>                                        loader=self.loader,<br>                                        passwords=self.passwords)<br><br>            <span class="hljs-comment"># 使用回调函数</span><br>            playbook._tqm._stdout_callback = self.results_callback<br>            <span class="hljs-comment"># 下面这些设置只有constants.HOST_KEY_CHECKING = False管用</span><br>            <span class="hljs-comment"># constants.HOST_KEY_CHECKING = False</span><br>            <span class="hljs-comment"># constants.CONNECT_TIMEOUT = 1200</span><br>            <span class="hljs-comment"># constants.COMMAND_TIMEOUT = 1200</span><br>            <span class="hljs-comment"># constants.ANSIBLE_PERSISTENT_CONNECT_TIMEOUT = 1200</span><br>            <span class="hljs-comment"># constants.ANSIBLE_PERSISTENT_COMMAND_TIMEOUT = 1200</span><br>            <span class="hljs-comment"># constants.TIMEOUT = 1200</span><br>            <span class="hljs-comment"># constants.CONFIG_FILE = &#x27;./888/ansible.cfg&#x27;</span><br>            <br>            result = playbook.run()<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">raise</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_result</span>(<span class="hljs-params">self</span>):</span><br>        result_raw = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.results_callback.task_ok:<br>            <span class="hljs-keyword">for</span> host, result <span class="hljs-keyword">in</span> i.items():<br>                <span class="hljs-keyword">if</span> result_raw.get(host):<br>                    result_raw[host][<span class="hljs-string">&quot;success&quot;</span>].update(&#123;result._task.get_name(): result._result&#125;)<br>                <span class="hljs-keyword">else</span>:<br>                    result_raw[host] = <span class="hljs-built_in">dict</span>()<br>                    result_raw[host][<span class="hljs-string">&quot;success&quot;</span>] = &#123;result._task.get_name(): result._result&#125;<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.results_callback.task_failed:<br>            <span class="hljs-keyword">for</span> host, result <span class="hljs-keyword">in</span> i.items():<br>                <span class="hljs-keyword">if</span> result_raw.get(host):<br>                    result_raw[host][<span class="hljs-string">&quot;failed&quot;</span>].update(&#123;result._task.get_name(): result._result&#125;)<br>                <span class="hljs-keyword">else</span>:<br>                    result_raw[host] = <span class="hljs-built_in">dict</span>()<br>                    result_raw[host][<span class="hljs-string">&quot;failed&quot;</span>] = &#123;result._task.get_name(): result._result&#125;<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.results_callback.task_unreachable:<br>            <span class="hljs-keyword">for</span> host, result <span class="hljs-keyword">in</span> i.items():<br>                <span class="hljs-keyword">if</span> result_raw.get(host):<br>                    result_raw[host][<span class="hljs-string">&quot;unreachable&quot;</span>].update(&#123;result._task.get_name(): result._result&#125;)<br>                <span class="hljs-keyword">else</span>:<br>                    result_raw[host] = <span class="hljs-built_in">dict</span>()<br>                    result_raw[host][<span class="hljs-string">&quot;unreachable&quot;</span>] = &#123;result._task.get_name(): result._result&#125;<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.results_callback.task_skipped:<br>            <span class="hljs-keyword">for</span> host, result <span class="hljs-keyword">in</span> i.items():<br>                <span class="hljs-keyword">if</span> result_raw.get(host):<br>                    result_raw[host][<span class="hljs-string">&quot;skipped&quot;</span>].update(&#123;result._task.get_name(): result._result&#125;)<br>                <span class="hljs-keyword">else</span>:<br>                    result_raw[host] = <span class="hljs-built_in">dict</span>()<br>                    result_raw[host][<span class="hljs-string">&quot;skipped&quot;</span>] = &#123;result._task.get_name(): result._result&#125;<br><br>        <span class="hljs-keyword">for</span> host, result <span class="hljs-keyword">in</span> self.results_callback.task_status.items():<br>            result_raw[host][<span class="hljs-string">&quot;status&quot;</span>] = result<br><br>        <span class="hljs-comment"># 最终打印结果，并且使用 JSON 继续格式化</span><br>        <span class="hljs-built_in">print</span>(json.dumps(result_raw, indent=<span class="hljs-number">4</span>))<br><br>        <span class="hljs-keyword">return</span> json.dumps(result_raw)<br><br></code></pre></td></tr></table></figure><p>callback输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;666.666.666.666&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;success&quot;</span>:&#123;<br>            <span class="hljs-attr">&quot;task_name&quot;</span>:result_result(这是一个字典)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不写python直接使用"><a href="#不写python直接使用" class="headerlink" title="不写python直接使用"></a>不写python直接使用</h3><p>首先需要添加目标机器的账号秘密，方式有两种：</p><ul><li><p>其一是在/etc/ansible/hosts中添加账号密码如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[test]</span><br><span class="hljs-number">10.222.21.1</span> ansible_ssh_user=root ansible_ssh_pass=tianbadunbatua<br></code></pre></td></tr></table></figure></li><li><p>上面的方式会明文暴露密码，方式二：使用ssh-copy-id使用拷贝秘钥的方式进行认证</p><p>首先执行：<code>ssh-copy-id -i /root/.ssh/id_rsa.pub root@10.1.1.1</code></p><p>然后会提示输入密码</p><p>再vim /etc/ansible/hosts,在里面只填写ip就行</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[test]</span><br><span class="hljs-number">10.222.21.1</span><br><span class="hljs-string">[pro]</span><br>xxx.xxx.xxx.x<br></code></pre></td></tr></table></figure></li><li><p>执行命令：<code>ansible all -a &quot;ls&quot;</code>,all这里是指对所有分组都做操作，可以换成test，-a是指arguments，命令行参数</p></li></ul><h3 id="相关参考资料"><a href="#相关参考资料" class="headerlink" title="相关参考资料"></a>相关参考资料</h3><p><a href="https://segmentfault.com/a/1190000023106094">https://segmentfault.com/a/1190000023106094</a></p><p><a href="https://www.jianshu.com/p/ec1e4d8438e9">https://www.jianshu.com/p/ec1e4d8438e9</a></p><p><a href="https://www.cnblogs.com/rexcheny/category/1264272.html">https://www.cnblogs.com/rexcheny/category/1264272.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Devops，Ansible</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes（k8s）之yaml文件详解</title>
    <link href="/2021/05/10/kubernetes%EF%BC%88k8s%EF%BC%89%E4%B9%8Byaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/05/10/kubernetes%EF%BC%88k8s%EF%BC%89%E4%B9%8Byaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># yaml格式的pod定义文件完整内容：</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>       <span class="hljs-comment">#必选，版本号，例如v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>       <span class="hljs-comment">#必选，Pod</span><br><span class="hljs-attr">metadata:</span>       <span class="hljs-comment">#必选，元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>       <span class="hljs-comment">#必选，Pod名称</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#必选，Pod所属的命名空间</span><br>  <span class="hljs-attr">labels:</span>      <span class="hljs-comment">#自定义标签</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#自定义标签名字</span><br>  <span class="hljs-attr">annotations:</span>       <span class="hljs-comment">#自定义注释列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br><span class="hljs-attr">spec:</span>         <span class="hljs-comment">#必选，Pod中容器的详细定义</span><br>  <span class="hljs-attr">containers:</span>      <span class="hljs-comment">#必选，Pod中容器列表</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#必选，容器名称</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#必选，容器的镜像名称</span><br>    <span class="hljs-attr">imagePullPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">IfNotPresent</span>] <span class="hljs-comment">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]    <span class="hljs-comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">string</span>]     <span class="hljs-comment">#容器的启动命令参数列表</span><br>    <span class="hljs-attr">workingDir:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#容器的工作目录</span><br>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-comment">#挂载到容器内部的存储卷配置</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#存储卷在容器内mount的绝对路径，应少于512字符</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-string">boolean</span>    <span class="hljs-comment">#是否为只读模式</span><br>    <span class="hljs-attr">ports:</span>       <span class="hljs-comment">#需要暴露的端口库号列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#端口号名称</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-string">int</span>   <span class="hljs-comment">#容器需要监听的端口号</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-string">int</span>    <span class="hljs-comment">#容器所在主机需要监听的端口号，默认与Container相同</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#端口协议，支持TCP和UDP，默认TCP</span><br>    <span class="hljs-attr">env:</span>       <span class="hljs-comment">#容器运行前需设置的环境变量列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#环境变量名称</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#环境变量的值</span><br>    <span class="hljs-attr">resources:</span>       <span class="hljs-comment">#资源限制和请求的设置</span><br>      <span class="hljs-attr">limits:</span>      <span class="hljs-comment">#资源限制的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span><br>      <span class="hljs-attr">requests:</span>      <span class="hljs-comment">#资源请求的设置</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">string</span>    <span class="hljs-comment">#Cpu请求，容器启动的初始可用数量</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#内存清楚，容器启动的初始可用数量</span><br>    <span class="hljs-attr">livenessProbe:</span>     <span class="hljs-comment">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span><br>      <span class="hljs-attr">exec:</span>      <span class="hljs-comment">#对Pod容器内检查方式设置为exec方式</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">string</span>]  <span class="hljs-comment">#exec方式需要制定的命令或脚本</span><br>      <span class="hljs-attr">httpGet:</span>       <span class="hljs-comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">HttpHeaders:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">tcpSocket:</span>     <span class="hljs-comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span><br>         <span class="hljs-attr">port:</span> <span class="hljs-string">number</span><br>       <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">0</span>  <span class="hljs-comment">#容器启动完成后首次探测的时间，单位为秒</span><br>       <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br>       <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">0</span>    <span class="hljs-comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br>       <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">0</span><br>       <span class="hljs-attr">securityContext:</span><br>         <span class="hljs-string">privileged:false</span><br>    <span class="hljs-attr">restartPolicy:</span> [<span class="hljs-string">Always</span> <span class="hljs-string">|</span> <span class="hljs-string">Never</span> <span class="hljs-string">|</span> <span class="hljs-string">OnFailure</span>]<span class="hljs-comment">#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span><br>    <span class="hljs-attr">nodeSelector:</span> <span class="hljs-string">obeject</span>  <span class="hljs-comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br>    <span class="hljs-attr">imagePullSecrets:</span>    <span class="hljs-comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>    <span class="hljs-string">hostNetwork:false</span>      <span class="hljs-comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br>    <span class="hljs-attr">volumes:</span>       <span class="hljs-comment">#在该pod上定义共享存储卷列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#共享存储卷名称 （volumes类型有很多种）</span><br>      <span class="hljs-attr">emptyDir:</span> &#123;&#125;     <span class="hljs-comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br>      <span class="hljs-attr">hostPath:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">string</span>     <span class="hljs-comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span><br>      <span class="hljs-attr">secret:</span>      <span class="hljs-comment">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span><br>        <span class="hljs-attr">scretname:</span> <span class="hljs-string">string</span>  <br>        <span class="hljs-attr">items:</span>     <br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">configMap:</span>     <span class="hljs-comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">items:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">string</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">string</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python日志管理工具logging如何消除重复打印问题，以及在项目中如何应用</title>
    <link href="/2021/04/22/python%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7logging%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8/"/>
    <url>/2021/04/22/python%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7logging%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="有这样一篇文章是解决重复打印的"><a href="#有这样一篇文章是解决重复打印的" class="headerlink" title="有这样一篇文章是解决重复打印的"></a>有这样一篇文章是解决重复打印的</h2><p><a href="https://blog.csdn.net/u011417820/article/details/112861970">https://blog.csdn.net/u011417820/article/details/112861970</a></p><ul><li>问题二其实不用考虑，因为不会有人在一个脚本里创建两个logger</li><li>问题一重复打印的问题，可以通过传递__name__或者if判断句柄两个其一进行解决，传递__name__就是为了避免生成相同name的logger对象，就会重复logg.addhandler，其实通过if判断句柄也可以达到相同的效果</li><li>关于为什么非要用一个类封装，一方面是面向对象的编程模式，另一方面也是为了以后可以扩展，其实也可以用一个函数代替，比如下面的例子</li></ul><h2 id="如何在项目中实际应用"><a href="#如何在项目中实际应用" class="headerlink" title="如何在项目中实际应用"></a>如何在项目中实际应用</h2><ul><li><p>除了封装成class，也可以</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br><span class="hljs-keyword">import</span> os<br><br><br>def create_logger(<span class="hljs-type">name</span>, output_dir=<span class="hljs-string">&#x27;.log&#x27;</span>)<br>logger = logging.getLogger(<span class="hljs-type">name</span>)<br>logger.setLevel(logging,<span class="hljs-keyword">INFO</span>)<br>formatter = logging.Formatter(&quot;%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s&quot;)<br><br># <span class="hljs-keyword">log</span> <span class="hljs-keyword">to</span> file<br>os.makedirs(output_dir, exist_ok=<span class="hljs-keyword">True</span>)<br><span class="hljs-type">timestamp</span> = <span class="hljs-type">time</span>.strftime(&quot;%Y%m%d-%H%M%S&quot;, <span class="hljs-type">time</span>.<span class="hljs-built_in">localtime</span>())<br>filename = os.path.<span class="hljs-keyword">join</span>(output_dir, f<span class="hljs-string">&#x27;&#123;timestamp&#125;.log&#x27;</span>)<br>fh = logging.FileHandler(filename)<br>fh.setFormatter(formatter)<br>logger.addHandler(fh)<br><br># <span class="hljs-keyword">log</span> <span class="hljs-keyword">to</span> console<br>ch = logging.StreamHandler()<br>ch.setFormatter(formatter)<br>logger.addHandler(ch)<br><br><span class="hljs-keyword">return</span> logger<br><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li><li><p>但是有一个问题是，如果在多个文件中调用，就会多次执行</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">fh</span> = logging.FileHandler(filename)<br></code></pre></td></tr></table></figure><p>创建出多个log文件，因为不同文件传进来的__name__是不一样的，如果想只创建一个log文件，可以不传入name，改用句柄判断如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import logging<br>import time<br>import os<br><br><br>def create<span class="hljs-constructor">_logger(<span class="hljs-params">output_dir</span>=&#x27;.<span class="hljs-params">log</span>&#x27;)</span><br>logger = logging.get<span class="hljs-constructor">Logger()</span><br>logger.set<span class="hljs-constructor">Level(<span class="hljs-params">logging</span>,INFO)</span><br>formatter = logging.<span class="hljs-constructor">Formatter(<span class="hljs-string">&quot;%(asctime)s - %(levelname)s - %(filename)s[:%(lineno)d] - %(message)s&quot;</span>)</span><br><span class="hljs-keyword">if</span> not logger.has<span class="hljs-constructor">Handlers()</span>:<br>        # log <span class="hljs-keyword">to</span> file<br>        os.makedirs(output_dir, exist_ok=True)<br>        timestamp = time.strftime(<span class="hljs-string">&quot;%Y%m%d-%H%M%S&quot;</span>, time.localtime<span class="hljs-literal">()</span>)<br>        filename = os.path.join(output_dir, f&#x27;&#123;timestamp&#125;.log&#x27;)<br>        fh = logging.<span class="hljs-constructor">FileHandler(<span class="hljs-params">filename</span>)</span><br>        fh.set<span class="hljs-constructor">Formatter(<span class="hljs-params">formatter</span>)</span><br>        logger.add<span class="hljs-constructor">Handler(<span class="hljs-params">fh</span>)</span><br><br>        # log <span class="hljs-keyword">to</span> console<br>        ch = logging.<span class="hljs-constructor">StreamHandler()</span><br>        ch.set<span class="hljs-constructor">Formatter(<span class="hljs-params">formatter</span>)</span><br>        logger.add<span class="hljs-constructor">Handler(<span class="hljs-params">ch</span>)</span><br><br>return logger<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>logging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerFile和DockerCompose使用总结</title>
    <link href="/2021/03/10/DockerFile%E5%92%8CDockerCompose%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/10/DockerFile%E5%92%8CDockerCompose%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 1、第一行必须是 FROM 基础镜像信息</span><br><span class="hljs-keyword">FROM</span> ubuntu<br> <br><span class="hljs-comment"># 2、维护者信息</span><br><span class="hljs-keyword">MAINTAINER</span> docker_user docker_user@email.com<br> <br><span class="hljs-comment"># 3、镜像操作指令</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot;</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="hljs-keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\ndaemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf</span><br> <br><span class="hljs-comment"># 4、容器启动执行指令</span><br><span class="hljs-keyword">CMD</span><span class="bash"> /usr/sbin/nginx</span><br></code></pre></td></tr></table></figure><p>Dockerfile 基本就长这样，当然这是一个很简单的例子，还有很多其他命令会在下个小节介绍。</p><p>有几点需要注意，第一行必须是 FROM 命令，表示是基于哪个基础镜像来创建镜像的。第二行一般是 MAINTAINER 命令，表示维护人信息，但不做硬性要求。最后一行是 CMD 命令，表示启动容器执行的命令，CMD 命令必须在最后一行，如果有多个 CMD 命令，则只有最后一个生效。</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><strong>FROM：</strong> 必须是 Dockerfile 的首个命令，定义了使用哪个基础镜像启动构建流程。</p><p><strong>MAINTAINER：</strong> 声明镜像作者。</p><p><strong>COPY：</strong> 将宿主机的文件拷贝到镜像内的指定路径。</p><p><strong>ADD：</strong> 作用类似于 <strong>COPY</strong>。</p><p><strong>COPY</strong> 和 <strong>ADD</strong> 的区别是：<strong>ADD</strong> 命令功能更多，比如拷贝一个压缩包，<strong>ADD</strong> 可以将压缩包解压到镜像内，如果是下载链接，<strong>ADD</strong> 会先下载文件，然后再拷贝。</p><p>但现在 docker 官方更推荐使用 <strong>COPY</strong> 命令，一个命令只做一件事。</p><p><strong>WORKDIR：</strong> 指定 Dockerfile 中该命令下的操作所在的工作目录。</p><p><strong>RUN：</strong> 执行命令行命令。</p><p><strong>ENV：</strong> 设置环境变量。</p><p><strong>VOLUME：</strong> 挂载数据卷。</p><p><strong>EXPOSE：</strong> 暴露端口。</p><p><strong>CMD：</strong> 服务启动命令。</p><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>有了 Dockerfile 之后，在 Dockerfile 所在目录执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker build -t &lt;image_name&gt; .</span><br></code></pre></td></tr></table></figure><p>就这么简单，镜像就创建好了。</p><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><h3 id="使用-docker-compose-部署-Redis-服务"><a href="#使用-docker-compose-部署-Redis-服务" class="headerlink" title="使用 docker-compose 部署 Redis 服务"></a>使用 docker-compose 部署 Redis 服务</h3><p>项目 Docker 化部署的最后一步，就差 Redis 了。本来以为是一件很简单的事，没想到折腾了我大半天的时间，下面就来分享分享我的采坑经历。</p><p>docker-compose 文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:3.2.12</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">host</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">/etc/redis.conf</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">6379</span><span class="hljs-string">:6379</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./redis.conf:/etc/redis.conf</span><br></code></pre></td></tr></table></figure><p>当前目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker-compose up</span><br></code></pre></td></tr></table></figure><p>本来以为服务一启，事情就这么愉快的结束了，但是，报错。</p><blockquote><p>Can’t open the log file: No such file or directory</p></blockquote><p>原因就是 redis.conf 文件直接用的是在物理机上部署时用的，<code>logfile</code> 参数配的是 <code>/var/lib/redis</code>，但 docker 容器里没有这个目录，但是有 <code>/data</code> 目录，所以，把 <code>logfile</code> 配置成 <code>/data</code> 即可。</p><p>改完之后再一启，没有任何信息输出，看来是成功了。</p><p><code>docker ps</code> 看看，没有容器。</p><p>这下给我整懵了，咋回事呢？其实报错都不怕，就怕启动不成功，还没有报错信息。</p><p>就这个问题给我折腾了好久，突然灵光一闪，想到 redis 会不会是以后台进程起的，导致容器直接退出。</p><p>检查一下配置文件中的 <code>daemonize</code> 参数，果然是 <code>yes</code>。改成 <code>no</code> 之后，就可以正常启动了。</p><p>就这么个破问题，卡了这么长时间，而且这类问题之前还遇到过，真是让人郁闷。</p><p>至此，项目中的所有服务就都 Docker 化部署了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的闭包和装饰器</title>
    <link href="/2021/03/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2021/03/09/Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>官方点的解释：内部函数（闭包函数）对外部函数作用域里变量的引用</li><li>原因：函数内的属性都是有生命周期的，生命周期是在函数执行期间，那么如果想在函数生命周期结束后仍然使用怎么办呢——采用闭包函数</li><li>函数内的闭包函数私有化了变量，完成了数据的封装，类似于面向对象</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift">def <span class="hljs-function"><span class="hljs-keyword">func</span>()</span>:  # 外部函数<br>    a <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  # 外部函数作用域里的变量<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is func.&quot;</span>)<br><br>    def func1(num):  # 内部函数（闭包函数）<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is func1&quot;</span>)<br>        <span class="hljs-built_in">print</span>(num <span class="hljs-operator">+</span> a)<br>    <span class="hljs-keyword">return</span> func1  # 函数<br><br><br># <span class="hljs-function"><span class="hljs-keyword">func</span>()</span>  # 运行外部函数，内部函数就被创建了<br><span class="hljs-keyword">var</span> <span class="hljs-operator">=</span> <span class="hljs-function"><span class="hljs-keyword">func</span>()</span>  # <span class="hljs-keyword">var</span> <span class="hljs-operator">=</span> func1<br><span class="hljs-keyword">var</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mercury">This <span class="hljs-keyword">is</span> <span class="hljs-keyword">func</span>.<br>This <span class="hljs-keyword">is</span> func1<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="装饰器（基于闭包）"><a href="#装饰器（基于闭包）" class="headerlink" title="装饰器（基于闭包）"></a>装饰器（基于闭包）</h2><ul><li>不影响原有函数的功能，还能添加新的功能</li><li>装饰器函数带参数：多一层包装来接受装饰器的参数</li><li>被装饰的函数带参数：只需要在最内部闭包函数内传入参数即可</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift">def func1(<span class="hljs-keyword">func</span>):  # 外部闭包函数的参数是被装饰的函数对象<br><br>    def func2():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;aaabbb&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span>()</span>  # 返回了外部装饰函数的参数被装饰的调用<span class="hljs-operator">。</span>注意这个括号一定要带，带了才是执行这个函数，否则是返回一个函数对象<br>    <span class="hljs-keyword">return</span> func2<br># <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-title">，返回集装箱</span></span><br># <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span>()</span>，返回函数调用<br><br><br><span class="hljs-meta">@func1</span><br>def myprint():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello i am print&quot;</span>)<br><br><br>myprint()  # 相当于func1(myprint)()<br></code></pre></td></tr></table></figure><p>参考：<a href="https://www.bilibili.com/video/BV1JW411i7HR/?spm_id_from=autoNext">https://www.bilibili.com/video/BV1JW411i7HR/?spm_id_from=autoNext</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的classmethod和staticmethod</title>
    <link href="/2021/03/08/Python%E4%B8%AD%E7%9A%84classmethod%E5%92%8Cstaticmethod/"/>
    <url>/2021/03/08/Python%E4%B8%AD%E7%9A%84classmethod%E5%92%8Cstaticmethod/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/28010894">https://zhuanlan.zhihu.com/p/28010894</a><br><a href="https://zhuanlan.zhihu.com/p/35643573">https://zhuanlan.zhihu.com/p/35643573</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署配置相关使用总结</title>
    <link href="/2020/12/22/Docker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/22/Docker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker部署配置相关使用总结"><a href="#Docker部署配置相关使用总结" class="headerlink" title="Docker部署配置相关使用总结"></a>Docker部署配置相关使用总结</h2><h3 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h3><p>使用 <code>docker run</code> 命令来创建并启动一个容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -it centos /bin/<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello world&#x27;</span></span><br>hello world<br></code></pre></td></tr></table></figure><p><code>-t</code> 参数让 Docker 分配一个伪终端，并绑定到容器的标准输入上，<code>-i</code> 参数让容器的标准输入持续打开。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker ps -a</span><br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES<br>df84684c3888        centos              &quot;/bin/echo &#x27;hello wo…&quot;   10 seconds ago      Exited (0) 7 seconds ago                       admiring_noyce<br></code></pre></td></tr></table></figure><p><code>docker ps</code> 命令列出当前的容器，可以看到，刚刚执行的容器输出完信息之后就直接退出了。那有没有办法让容器在后台执行呢？答案当然是可以的。</p><p>使用 <code>-d</code> 参数让容器在后台，以守护进程的方式执行，这也是在工作中最常用到的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -d centos /bin/sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br>fcb07a324388d58883e212ff5675ad7947a22c731f677d1a37ff7bc3d8bfa9a7<br><br><span class="hljs-meta">$</span><span class="bash"> docker ps</span><br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br>fcb07a324388        centos              &quot;/bin/sh -c &#x27;while t…&quot;   6 seconds ago       Up 5 seconds                            beautiful_northcutt<br></code></pre></td></tr></table></figure><p>这样容器就在后台运行了。</p><p>还有一种方式，使用 <code>docker create</code> 命令创建容器，然后使用 <code>docker start</code> 来启动容器，两条命令相当于 <code>docker run</code> 一条，这种方式不常用，就不做更多介绍了。</p><p>下面聊聊 <code>docker run</code> 背后的故事，到底这一条命令背后，Docker 都为我们做了哪些操作呢？</p><ul><li>检查本地是否存在指定镜像，不存在就从公有仓库下载；</li><li>使用镜像创建并启动一个容器；</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层；</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；</li><li>从地址池配置一个 IP 地址给容器；</li><li>执行用户指定的命令或应用程序；</li><li>执行完毕后容器被终止。</li></ul><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>当容器以后台方式执行时，使用 <code>docker exec</code> 命令进入到容器中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker ps</span><br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br>fcb07a324388        centos              &quot;/bin/sh -c &#x27;while t…&quot;   6 seconds ago       Up 5 seconds                            beautiful_northcutt<br><br><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it fcb07a324388 /bin/bash</span><br>[root@fcb07a324388 /]# ls<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>[root@fcb07a324388 /]#<br></code></pre></td></tr></table></figure><p>进入到容器之后，就是一个 Linux 系统，Linux 支持的命令，容器也基本都支持。</p><p>这条命令还是比较重要的，有时候我们的应用出问题了，单纯通过 logs 看不出问题的话，就需要我们进入容器，来看看实际情况。</p><p>想退出的话，直接 <code>exit</code> 命令就可以了。</p><p>还有一个命令是 <code>docker attach</code>，但是它有一个缺点。当多个窗口同时 attach 到同一个容器时，所有窗口都会同步显示，当某个窗口因命令阻塞时，其他窗口也无法执行操作。</p><p>所以，这个命令现在基本也不用了。</p><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>使用 <code>docker stop</code> 命令来停止一个容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker stop fcb</span><br>fcb<br><span class="hljs-meta">$</span><span class="bash"> docker ps -a</span><br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS               NAMES<br>fcb07a324388        centos              &quot;/bin/sh -c &#x27;while t…&quot;   23 minutes ago      Exited (137) 4 seconds ago                       beautiful_northcutt<br></code></pre></td></tr></table></figure><p>如果再想启动的话，使用 <code>docker start</code>。</p><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>上文已经介绍过了，使用 <code>docker ps</code> 命令查看当前容器。</p><p>使用 <code>docker logs</code> 查看容器日志输出。</p><p>使用 <code>docker container inspect</code> 命令查看容器的详细信息。</p><p>使用 <code>docker top</code> 命令查看容器内进程信息，类似 Linux 下的 top 命令。</p><p>使用 <code>docker stats</code> 命令查看容器 CPU，内存，储存等信息。</p><p>使用 <code>docker container port</code> 查看容器的端口映射情况。</p><h3 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h3><p>使用 <code>docker export</code> 命令导出一个容器到文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker ps</span><br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES<br>fcb07a324388        centos              &quot;/bin/sh -c &#x27;while t…&quot;   34 minutes ago      Up 9 minutes                            beautiful_northcutt<br><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">export</span> -o centos.tar fcb</span><br><span class="hljs-meta">$</span><span class="bash"> ls</span><br>centos.tar<br></code></pre></td></tr></table></figure><p>使用 <code>docker import</code> 命令将容器文件导入成本地镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker import centos.tar <span class="hljs-built_in">test</span>/centos</span><br>sha256:f994c062dae063ffb8c97191d951b9beaac73d99023120191dbbc9741d725578<br><span class="hljs-meta">$</span><span class="bash"> docker images</span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>test/centos         latest              f994c062dae0        6 seconds ago       237MB<br></code></pre></td></tr></table></figure><p>在上一篇文章中介绍了一个 <code>docker load</code> 命令，同样是将文件导入成本地镜像，那二者有什么区别呢？</p><p>容器快照文件将丢弃所有历史记录和元数据信息，而镜像存储文件将保存完整记录，但体积更大。</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>使用 <code>docker rm</code> 命令来删除已经停止的容器，如果容器正在运行，可以加 <code>-f</code> 参数进行强制删除。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>docker 删除container或删除images<br>删除所有不在运行的容器docker rm $(docker ps -a -q)<br>暂停容器 docker stop +ID<br>删除镜像 docker rmi +ID或者docker image rm<br>Docker添加环境变量，不是用RUN export的方式，这种方式只在当前层有效，而ENV是贯穿所有setp的<br>ENV http_proxy http:<br>ENV https_proxy http:</p></li><li><p>关于这行命令<code>docker build -t iris-classifier $saved_path</code><br>先说<code>$</code>是表示<code>$</code>后面的是一个变量，如果不加则是saved_path字符串<br>参数<code>-t</code>是指定name和tag，例如：<code>ner-service:latest</code>,冒号前是name，冒号后是tag，默认是使用当前路径下的Dockerfile文件进行构建，如果文件不在当前路径或者名字不叫Dockerfile，则用-f进行指定。$saved_path是指构建image的时候用到的文件，如果在当前目录下也需要传一个.<br>这个命令会把Dockerfile和当前文件夹的文件传到deamon，生成一个image再传回本地，但是这个image不会以实体文件的形式存在当前目录下，他只是和其他docker run文件一样放在其他地方，通过docker images可以查看当前所有的images。如果想保存则可以使用save命令</p></li><li><p>打包docker 镜像到当前目录<br>docker save ner-service &gt; ner-service.tar<br>镜像导入<br>docker load –input ner-service.tar<br>镜像导出和容器导出<br><a href="https://www.jianshu.com/p/8408e06b7273">https://www.jianshu.com/p/8408e06b7273</a><br>top命令查看资源占用情况<br>docker run -p 5000:5000 ner-service</p></li></ul><p>-p 5000:5000是把容器的5000端口暴露到本机的5000</p><h2 id="Docker-ARG-vs-ENV"><a href="#Docker-ARG-vs-ENV" class="headerlink" title="Docker ARG vs ENV"></a>Docker ARG vs ENV</h2><p>构建 Docker 镜像的的时候有两种环境变量 ARG 和 ENV, 一种是在运行 build 命令时通过 –build-arg 参数设置的 build-time variables 以及通过在 dockerfile 里面设置 ENV 指令配置的环境变量，本文说明它们之间的区别。</p><ul><li>ARG<ul><li>Dockerfile 里面的 ARG 指令定义了一个变量，在运行 docker build 命令时使用 –build-arg <varname> = <value> 参数将其传递给构建器。</li><li>这种变量只存在于镜像构建的时候，一旦镜像构建完成就失效了，不要使用构建时变量来传递诸如 github 密钥，用户凭据等机密数据，构建时变量值可以使用 docker history 命令查看。</li></ul></li><li>ENV<ul><li>Dockerfile 里面的 ENV 指令将环境变量 设置为值 ，这个变量将在构建阶段中所有后续指令的环境中使用。</li><li>使用 ENV 设置的环境变量将一直存在于构建镜像时以及镜像容器运行时，可以使用 docker inspect 查看设置打的变量。也可以使用 docker run –env <key> = <value> 来更改它们。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像质量评估中的PSNR和SSIM的定义，公式和含义</title>
    <link href="/2020/02/03/%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BC%B0%E4%B8%AD%E7%9A%84PSNR%E5%92%8CSSIM%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%85%AC%E5%BC%8F%E5%92%8C%E5%90%AB%E4%B9%89/"/>
    <url>/2020/02/03/%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BC%B0%E4%B8%AD%E7%9A%84PSNR%E5%92%8CSSIM%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%85%AC%E5%BC%8F%E5%92%8C%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="PSNR"><a href="#PSNR" class="headerlink" title="PSNR"></a>PSNR</h1><p>峰值信噪比（PSNR）， 一种评价图像的客观标准，应用场景有很多。它具有局性，PSNR是“Peak Signal to Noise Ratio”的缩写。peak的中文意思是顶点。而ratio的意思是比率或比列的。整个意思就是到达噪音比率的顶点信号，psnr一般是用于最大值信号和背景噪音之间的一个工程项目。通常在经过影像压缩之后，通常输 出的影像都会在某种程度与原始影像不同。为了衡量经过处理后的影像品质，我们通常会参考PSNR值来衡量某个处理程序能否令人满意。它是原图像与被处理图 像之间的均方误差相对于(2^n-1)^2的对数值(信号最大值的平方，n是每个采样值的比特数)，它的单位是dB。<br><img src="https://img-blog.csdnimg.cn/20200203174618621.png" alt="在这里插入图片描述"><br>其中，MSE表示当前图像X和参考图像Y的均方误差（MeanSquare Error），X(i,j)，Y(i,j)分别代表对应坐标处的像素值，H、W分别为图像的高度和宽度；n为每像素的比特数，一般取8，即像素灰阶数为256. PSNR的单位是dB，数值越大表示失真越小。，因为数值越大代表MSE越小。MSE越小代表两张图片越接近，失真就越小。</p><p>PSNR是最普遍和使用最为广泛的一种图像客观评价指标，然而它是基于对应像素点间的误差，即 基于误差敏感的图像质量评价。由于并未考虑到人眼的视觉特性（人眼对空间频率较低的对比差异敏感度较高，人眼对亮度对比差异的敏感度较色度高，人眼对一个 区域的感知结果会受到其周围邻近区域的影响等），因而经常出现评价结果与人的主观感觉不一致的情况。</p><h1 id="SSIM"><a href="#SSIM" class="headerlink" title="SSIM"></a>SSIM</h1><p>SSIM的全称为structural similarity index，即为结构相似性，是一种衡量两幅图像相似度的指标。该指标首先由德州大学奥斯丁分校的图像和视频工程实验室(Laboratory for Image and Video Engineering)提出。而如果两幅图像是压缩前和压缩后的图像，那么SSIM算法就可以用来评估压缩后的图像质量。</p><p>SSIM如何表征相似性：<br>先给出一组公式：<br><img src="https://img-blog.csdnimg.cn/20200203180810909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3ODgzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>uX、uY分别表示图像X和Y的均值，σX、σY分别表示图像X和Y的标准差，σX<em>σX、σY</em>σY（实在打不出上标啊，理解万岁）分别表示图像X和Y的方差。σXY代表图像X和Y协方差。C1，C2和C3为常数，是为了避免分母为0而维持稳定。通常取C1=(K1<em>L)^2, C2=(K2</em>L)^2, C3=C2/2, 一般地K1=0.01, K2=0.03, L=255（ 是像素值的动态范围，一般都取为255）</p><p>最后的SSIM指数为：<br><img src="https://img-blog.csdnimg.cn/20200203180817446.png" alt="在这里插入图片描述"></p><p>当我们设定C3=C2/2时，我们可以将公式改写成更加简单的形式：<br><img src="https://img-blog.csdnimg.cn/20200203180835512.png" alt="在这里插入图片描述"></p><p>所以结构相似度指数从图像组成的角度将结构信息定义为独立于亮度、对比度的反映场景中物体结构的属性，并将失真建模为亮度、对比度和结构三个不同因素的组合。用均值作为亮度的估计，标准差作为对比度的估计，协方差作为结构相似程度的度量。</p><p>如何求得均值，方差与标准差：</p><p><img src="https://img-blog.csdnimg.cn/2020020318083832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3ODgzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>而在实际应用中，一般采用高斯函数计算图像的均值、方差以及协方差，而不是采用遍历像素点的方式，以换来更高的效率。</p><p>至于为什么采用高斯函数计算图像的均值、方差以及协方差，还有待深究</p><p>在实际应用中，可以利用滑动窗将图像分块，令分块总数为N，考虑到窗口形状对分块的影响，采用高斯加权计算每一窗口的均值、方差以及协方差，然后计算对应块的结构相似度SSIM，最后将平均值作为两图像的结构相似性度量，即平均结构相似性MSSIM。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DenseNet详解</title>
    <link href="/2019/07/16/DenseNet%E8%AF%A6%E8%A7%A3/"/>
    <url>/2019/07/16/DenseNet%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[</ul><h2><a name="t0"></a><strong>一、概述</strong></h2><p>作为CVPR2017年的Best Paper, DenseNet脱离了加深网络层数(ResNet)和加宽网络结构(Inception)来提升网络性能的定式思维,从特征的角度考虑,通过特征重用和旁路(Bypass)设置,既大幅度减少了网络的参数量,又在一定程度上缓解了gradient vanishing问题的产生.结合信息流和特征复用的假设,DenseNet当之无愧成为2017年计算机视觉顶会的年度最佳论文.</p><p>卷积神经网络在沉睡了近20年后,如今成为了深度学习方向最主要的网络结构之一.从一开始的只有五层结构的LeNet, 到后来拥有19层结构的VGG, 再到首次跨越100层网络的Highway Networks与ResNet, 网络层数的加深成为CNN发展的主要方向之一.</p><p>随着CNN网络层数的不断增加,gradient vanishing和model degradation问题出现在了人们面前,BatchNormalization的广泛使用在一定程度上缓解了gradient vanishing的问题,而ResNet和Highway Networks通过构造恒等映射设置旁路,进一步减少了gradient vanishing和model degradation的产生.Fractal Nets通过将不同深度的网络并行化,在获得了深度的同时保证了梯度的传播,随机深度网络通过对网络中一些层进行失活,既证明了ResNet深度的冗余性,又缓解了上述问题的产生. 虽然这些不同的网络框架通过不同的实现加深的网络层数,但是他们都包含了相同的核心思想,既将feature map进行跨网络层的连接.</p><p style="text-align:center;"><img alt="" class="has" height="469" src="https://img-blog.csdn.net/20180827164003429?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="608"></p><p>DenseNet作为另一种拥有较深层数的卷积神经网络,具有如下优点:</p><p>(1) 相比ResNet拥有更少的参数数量.</p><p>(2) 旁路加强了特征的重用.</p><p>(3) 网络更易于训练,并具有一定的正则效果.</p><p>(4) 缓解了gradient vanishing和model degradation的问题.</p><p>何恺明先生在提出ResNet时做出了这样的假设:若某一较深的网络多出另一较浅网络的若干层有能力学习到恒等映射,那么这一较深网络训练得到的模型性能一定不会弱于该浅层网络.通俗的说就是如果对某一网络中增添一些可以学到恒等映射的层组成新的网路,那么最差的结果也是新网络中的这些层在训练后成为恒等映射而不会影响原网络的性能.同样DenseNet在提出时也做过假设:与其多次学习冗余的特征,特征复用是一种更好的特征提取方式.</p><p>&nbsp;</p><h2><a name="t1"></a><strong>二、DenseNet</strong></h2><p>假设输入为一个图片&nbsp;<img alt="X_{0}" class="has" src="https://www.zhihu.com/equation?tex=X_%7B0%7D">&nbsp;, 经过一个L层的神经网络, 其中第i层的非线性变换记为&nbsp;<img alt="H_{i}" class="has" src="https://www.zhihu.com/equation?tex=H_%7Bi%7D">&nbsp;(*),&nbsp;<img alt="H_{i}" class="has" src="https://www.zhihu.com/equation?tex=H_%7Bi%7D">&nbsp;(*)可以是多种函数操作的累加如BN、ReLU、Pooling或Conv等. 第i层的特征输出记作&nbsp;<img alt="X_{i}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bi%7D">&nbsp;.</p><blockquote>ResNet</blockquote><p>传统卷积前馈神经网络将第i层的输出&nbsp;<img alt="X_{i}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bi%7D">&nbsp;作为i+1层的输入,可以写作<img alt="X_{i}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bi%7D">&nbsp;=&nbsp;<img alt="H_{i}" class="has" src="https://www.zhihu.com/equation?tex=H_%7Bi%7D">&nbsp;(&nbsp;<img alt="X_{i-1}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bi-1%7D">&nbsp;). ResNet增加了旁路连接,可以写作</p><p><img alt="X_{l}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bl%7D">&nbsp;=&nbsp;<img alt="X_{l}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bl%7D">&nbsp;(&nbsp;<img alt="X_{l-1}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bl-1%7D">&nbsp;)+&nbsp;<img alt="X_{l-1}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bl-1%7D"></p><p>ResNet的一个最主要的优势便是梯度可以流经恒等函数来到达靠前的层.但恒等映射和非线性变换输出的叠加方式是相加, 这在一定程度上破坏了网络中的信息流.</p><blockquote>Dense Connectivity</blockquote><p>为了进一步优化信息流的传播,DenseNet提出了图示的网络结构</p><p style="text-align:center;"><img alt="" class="has" height="472" src="https://img-blog.csdn.net/20180827164127931?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="615"></p><p>如图所示,第i层的输入不仅与i-1层的输出相关,还有所有之前层的输出有关.记作:</p><p><img alt="X_{l}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bl%7D">&nbsp;=&nbsp;<img alt="H_{l}" class="has" src="https://www.zhihu.com/equation?tex=H_%7Bl%7D">&nbsp;([&nbsp;<img alt="X_{0}" class="has" src="https://www.zhihu.com/equation?tex=X_%7B0%7D">&nbsp;,&nbsp;<img alt="X_{1}" class="has" src="https://www.zhihu.com/equation?tex=X_%7B1%7D">&nbsp;,…,&nbsp;<img alt="X_{l-1}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bl-1%7D">&nbsp;]),</p><p>其中[]代表concatenation(拼接),既将&nbsp;<img alt="X_{0}" class="has" src="https://www.zhihu.com/equation?tex=X_%7B0%7D">&nbsp;到&nbsp;<img alt="X_{l-1}" class="has" src="https://www.zhihu.com/equation?tex=X_%7Bl-1%7D">&nbsp;层的所有输出feature map按Channel组合在一起.这里所用到的非线性变换H为BN+ReLU+ Conv(3×3)的组合.</p><blockquote>Pooling Layers</blockquote><p>由于在DenseNet中需要对不同层的feature map进行cat操作,所以需要不同层的feature map保持相同的feature size,这就限制了网络中Down sampling的实现.为了使用Down sampling,作者将DenseNet分为多个Denseblock,如下图所示:</p><p style="text-align:center;"><img alt="" class="has" height="137" src="https://img-blog.csdn.net/20180827164206908?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="632"></p><p>在同一个Denseblock中要求feature size保持相同大小,在不同Denseblock之间设置transition layers实现Down sampling, 在作者的实验中transition layer由BN + Conv(1×1) ＋2×2 average-pooling组成.</p><blockquote>Growth rate</blockquote><p>在Denseblock中,假设每一个非线性变换H的输出为K个feature map, 那么第i层网络的输入便为K<em>0</em>+(i-1)×K, 这里我们可以看到DenseNet和现有网络的一个主要的不同点:DenseNet可以接受较少的特征图数量作为网络层的输出,如下图所示</p><p style="text-align:center;"><img alt="" class="has" height="294" src="https://img-blog.csdn.net/20180827164238251?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="639"></p><p>原因就是在同一个Denseblock中的每一层都与之前所有层相关联,如果我们把feature看作是一个Denseblock的全局状态,那么每一层的训练目标便是通过现有的全局状态,判断需要添加给全局状态的更新值.因而每个网络层输出的特征图数量K又称为Growth rate,同样决定着每一层需要给全局状态更新的信息的多少.我们之后会看到,在作者的实验中只需要较小的K便足以实现state-of-art的性能.</p><blockquote>Bottleneck Layers</blockquote><p>虽然DenseNet接受较少的k,也就是feature map的数量作为输出,但由于不同层feature map之间由cat操作组合在一起,最终仍然会是feature map的channel较大而成为网络的负担.作者在这里使用1×1 Conv(Bottleneck)作为特征降维的方法来降低channel数量,以提高计算效率.经过改善后的非线性变换变为BN-ReLU-Conv(1×1)-BN-ReLU-Conv(3×3),使用Bottleneck layers的DenseNet被作者称为DenseNet-B.在实验中,作者使用1×1卷积生成channel数量为4k的feature map.</p><blockquote>Compression</blockquote><p>为了进一步优化模型的简洁性,我们同样可以在transition layer中降低feature map的数量.若一个Denseblock中包含m个feature maps,那么我们使其输出连接的transition layer层生成⌊θm⌋个输出feature map.其中θ为Compression factor, 当θ=1时,transition layer将保留原feature维度不变.</p><p>作者将使用compression且θ=0.5的DenseNet命名为DenseNet-C, 将使用Bottleneck和compression且θ=0.5的DenseNet命名为DenseNet-BC</p><p>&nbsp;</p><h2><a name="t2"></a><strong>三、 算法分析</strong></h2><blockquote>(1) Model compactness</blockquote><p>由于DenseNet对输入进行cat操作,一个直观的影响就是每一层学到的feature map都能被之后所有层直接使用,这使得特征可以在整个网络中重用,也使得模型更加简洁.</p><p style="text-align:center;"><img alt="" class="has" height="217" src="https://img-blog.csdn.net/20180827164317605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="638"></p><p>从上图中我们可以看出DenseNet的参数效率:左图包含了对多种DenseNet结构参数和最终性能的统计,我们可以看出当模型实现相同的test error时,原始的DenseNet往往要比DenseNet-BC拥有2-3倍的参数量.中间图为DenseNet-BC与ResNet的对比,在相同的模型精度下,DenseNet-BC只需要ResNet约三分之一的参数数量.右图为1001层超过10M参数量的ResNet与100层只有0.8M参数量的DenseNet-BC在训练时的对比,虽然他们在约相同的训练epoch时收敛,但DenseNet-BC却只需要ResNet不足十分之一的参数量.</p><blockquote>(2) Implicit Deep Supervision</blockquote><p>解释DenseNet为何拥有如此高性能的另一个原因是网络中的每一层不仅接受了原始网络中来自loss的监督,同时由于存在多个bypass与shortcut,网络的监督是多样的.Deep supervision的优势同样在deeply-supervised nets (DSN)中也被证实.(DSN中每一个Hidden layer都有一个分类器,强迫其学习一些有区分度的特征).与DSN不同的是,DenseNet拥有单一的loss function, 模型构造和梯度计算更加简易.</p><blockquote>(3) Feature Reuse</blockquote><p>在设计初,DenseNet便被设计成让一层网络可以使用所有之前层网络feature map的网络结构,为了探索feature的复用情况,作者进行了相关实验.作者训练的L=40,K=12的DenseNet,对于任意Denseblock中的所有卷积层,计算之前某层feature map在该层权重的绝对值平均数.这一平均数表明了这一层对于之前某一层feature的利用率,下图为由该平均数绘制出的热力图:</p><p style="text-align:center;"><img alt="" class="has" height="370" src="https://img-blog.csdn.net/20180827164359337?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="762"></p><p>从图中我们可以得出以下结论:</p><p>a) 一些较早层提取出的特征仍可能被较深层直接使用</p><p>b) 即使是Transition layer也会使用到之前Denseblock中所有层的特征</p><p>c) 第2-3个Denseblock中的层对之前Transition layer利用率很低,说明transition layer输出大量冗余特征.这也为DenseNet-BC提供了证据支持,既Compression的必要性.</p><p>d) 最后的分类层虽然使用了之前Denseblock中的多层信息,但更偏向于使用最后几个feature map的特征,说明在网络的最后几层,某些high-level的特征可能被产生.</p><p>&nbsp;</p><h2><a name="t3"></a><strong>四、实验结果</strong></h2><p>作者在多个benchmark数据集上训练了多种DenseNet模型,并与state-of-art的模型(主要是ResNet和其变种)进行对比:</p><p style="text-align:center;"><img alt="" class="has" height="502" src="https://img-blog.csdn.net/20180827164443120?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="812"></p><p>由上表我们可以看出,DenseNet只需要较小的Growth rate(12,24)便可以实现state-of-art的性能,结合了Bottleneck和Compression的DenseNet-BC具有远小于ResNet及其变种的参数数量,且无论DenseNet或者DenseNet-BC,都在原始数据集和增广数据集上实现了超越ResNet的性能.</p><p>&nbsp;</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django多进程中的查询错乱问题以及mysql gone away问题</title>
    <link href="/2019/07/16/Django%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Amysql%20gone%20away%E9%97%AE%E9%A2%98/"/>
    <url>/2019/07/16/Django%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Amysql%20gone%20away%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>Django多进程中的查询错乱问题<br>因为业务需要，写了一个多进程程序，但是发现查询结果错乱，比如在同一个进程里输出<br><code>Asset.object.get(ip=1.1.1.1).ip</code><br>发现输出的并不是1.1.1.1</p><p>初步感觉是django底层用的musql_db这个库是进程不安全的，也就是不支持多进程操作，所以这种情况最好用多线程</p></li><li><p>关于mysql gone away的问题</p><p>一开始我以为是connections.close_all()函数导致的，如果在这句话前面查询出了一个对象，又执行这个关闭数据库链接的操作，然后再用这个对象执行一些修改或者需要联网的多表级联的操作会报错，其实不是的。在每一次需要联网操作的时候，如果发现没有这个链接，他会自动重新链接，不会报错</p><p>那什么情况下会报gone away这个错误呢？</p><p>子进程会fork父进程中的链接，但是这两个进程的计时不一样，mysql db中额外有一个计时器模块，来控制这些链接的终端与否，因为时间上对不上了所以会报错。（有待考证）</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C C++中关于全局变量静态变量，extern，static，const的区别与总结</title>
    <link href="/2019/06/10/C%20C++%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%8Cextern%EF%BC%8Cstatic%EF%BC%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2019/06/10/C%20C++%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%8Cextern%EF%BC%8Cstatic%EF%BC%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1><font face="Arial black" color=red size=7>一.extern</font></h1><h2 id="1-基本解释"><a href="#1-基本解释" class="headerlink" title="1 基本解释"></a>1 基本解释</h2><p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。</p><p>也就是说extern有两个作用，第一个,当它与”C”一起连用时，如: extern “C” void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!<br>第二，当extern不与”C”在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。</p><h2 id="2-问题：extern-变量"><a href="#2-问题：extern-变量" class="headerlink" title="2 问题：extern 变量"></a>2 问题：extern 变量</h2><p>　　在一个源文件里定义了一个数组：char a[6];<br>　　在另外一个文件里用下列语句进行了声明：extern char <em>a；<br>　　请问，这样可以吗？<br>　　答案与分析：<br>　　1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char <em>a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。<br>　　2)、例子分析如下，如果a[] = “abcd”,则外部变量a=0x61626364 (abcd的ASCII码值)，</em>a显然没有意义<br>　　显然a指向的空间（0x61626364）没有意义，易出现非法内存访问。<br>　　3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。<br>　　4)、extern用在变量声明中常常有这样一个作用，你在</em>.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在*.h中并用extern来声明。</p><h2 id="3-问题：当方面修改extern-函数原型"><a href="#3-问题：当方面修改extern-函数原型" class="headerlink" title="3 问题：当方面修改extern 函数原型"></a>3 问题：当方面修改extern 函数原型</h2><p>　　当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？<br>　　答案与分析：<br>　　目前业界针对这种情况的处理没有一个很完美的方案，通常的做法是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。<br>　　宝剑有双锋，对extern的应用，不同的场合应该选择不同的做法。</p><h2 id="4-问题：extern-“C”"><a href="#4-问题：extern-“C”" class="headerlink" title="4 问题：extern “C”"></a>4 问题：extern “C”</h2><p>　　在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？</p><p>　　答案与分析：<br>　　C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。<br>　　下面是一个标准的写法：<br>//在.h文件的头上<br>#ifdef __cplusplus<br>#if __cplusplus<br>extern “C”{<br>　#endif<br>　#endif /* __cplusplus */<br>　…<br>　…<br>　//.h文件结束的地方<br>　#ifdef __cplusplus<br>　#if __cplusplus<br>}<br>#endif<br>#endif /* __cplusplus */ </p><h2 id="5-问题：extern-函数声明"><a href="#5-问题：extern-函数声明" class="headerlink" title="5 问题：extern 函数声明"></a>5 问题：extern 函数声明</h2><p>　　常常见extern放在函数的前面成为函数声明的一部分，那么，C语言的关键字extern在函数的声明中起什么作用？<br>　　答案与分析：<br>　　如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即下述两个函数声明没有明显的区别：<br>extern int f(); 和int f();<br>　　当然，这样的用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。关于这样做的原因和利弊可见下面的这个例子：“用extern修饰的全局变量”</p><p>(1) 在test1.h中有下列声明:<br>#ifndef TEST1H<br>#define TEST1H<br>extern char g_str[]; // 声明全局变量g_str<br>void fun1();<br>#endif<br>(2) 在test1.cpp中<br>#include “test1.h”<br>    char g_str[] = “123456”; // 定义全局变量g_str<br>    void fun1() { cout &lt;&lt; g_str &lt;&lt; endl; }<br>(3) 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了<br>#include “test1.h”</p><p> void fun2()    { cout &lt;&lt; g_str &lt;&lt; endl;    }<br>    以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraEdit打开test1.obj,你可以在里面找到”123456”这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份,test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!<br>    (4) 有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为<br>    extern char g_str[] = “123456”; // 这个时候相当于没有extern<br>    然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报连接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而test2.cpp也包含了test1.h所以再一次定义了g_str,这个时候连接器在连接test1和test2时发现两个g_str。如果你非要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include “test1.h”去掉 换成:<br>    extern char g_str[];<br>    void fun2()   {  cout &lt;&lt; g_str &lt;&lt; endl;   }<br>   这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是我想说这样做非常糟糕，因为你由于无法在test2.cpp中使用#include “test1.h”,那么test1.h中声明的其他函数你也无法使用了，除非也用都用extern修饰，这样的话你光声明的函数就要一大串，而且头文件的作用就是要给外部提供接口使用的，所以 请记住， 只在头文件中做声明，真理总是这么简单。</p><h2 id="6-extern-和-static"><a href="#6-extern-和-static" class="headerlink" title="6. extern 和 static"></a>6. extern 和 static</h2><p> (1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.<br> (2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.<br>对于一个完整的程序，在内存中的分布情况如下图：　<br>1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。<br>3.堆区：程序员分配并释放的区域，像malloc(c),new(c++)<br>3.全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。<br>4.代码区</p><p> static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern 引用,而static 不可以,只允许对象本身用它. 具体差别首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:<br>    (1) test1.h:<br>    #ifndef TEST1H<br>    #define TEST1H<br>    static char g_str[] = “123456”;<br>    void fun1();<br>    #endif</p><p> (2) test1.cpp:<br>    #include “test1.h”<br>    void fun1()  {   cout &lt;&lt; g_str &lt;&lt; endl;  }<br>    (3) test2.cpp<br>    #include “test1.h”<br>    void fun2()  {   cout &lt;&lt; g_str &lt;&lt; endl;  }<br>    以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串”123456”,同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1,test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的”123456”, 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了，如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:<br>    (1) test1.cpp:<br>    #include “test1.h”<br>    void fun1()<br>    {<br>        g_str[0] = ‘’a’’;<br>        cout &lt;&lt; g_str &lt;&lt; endl;<br>    }</p><p>(2) test2.cpp<br>#include “test1.h”<br>void fun2()  {  cout &lt;&lt; g_str &lt;&lt; endl;  }<br>(3) void main()     {<br>    fun1(); // a23456<br>    fun2(); // 123456<br>}<br>这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。正是因为static有以上的特性，所以一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染，同样记住这个原则吧！</p><h2 id="7-extern-和const"><a href="#7-extern-和const" class="headerlink" title="7. extern 和const"></a>7. extern 和const</h2><p>   C++中const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，但是const可以与extern连用来声明该常量可以作用于其他编译模块中, 如extern const char g_str[];然后在原文件中别忘了定义:     const char g_str[] = “123456”; 所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了！所以对const我没有什么可以过多的描述，我只是想提醒你，const char* g_str = “123456” 与 const char g_str[] =”123465”是不同的， 前面那个const 修饰的是char <em>而不是g_str,它的g_str并不是常量，它被看做是一个定义了的全局变量（可以被其他编译单元使用）， 所以如果你像让char</em>g_str遵守const的全局常量的规则，最好这么定义const char* const g_str=”123456”.</p><h1><font face="Arial black" color=Red size=7>二.static</font></h1><h2 id="C-语言的-static-关键字有三种（具体来说是两种）用途："><a href="#C-语言的-static-关键字有三种（具体来说是两种）用途：" class="headerlink" title="C 语言的 static 关键字有三种（具体来说是两种）用途："></a>C 语言的 static 关键字有三种（具体来说是两种）用途：</h2><ol><li><p>静态局部变量：用于函数体内部修饰变量，这种变量的生存期长于该函数。</p><pre><code>int foo()&#123;         static int i = 1; // note:1         //int i = 1;  // note:2         i += 1;         return i;     &#125;</code></pre></li></ol><p>要明白这个用法，我们首先要了解c/c++的内存分布，以及static所在的区间。</p><p>对于一个完整的程序，在内存中的分布情况如下图：　<br>1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。<br>3.堆区：程序员分配并释放的区域，像malloc(c),new(c++)<br>3.全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。<br>4.代码区</p><p>所以上面note:1的static是在全局数据区分配的,那么它存在的意思是什么？又是什么时候初始化的呢？</p><p>首先回答第一个问题：它存在的意义就是随着第一次函数的调用而初始化，却不随着函数的调用结束而销毁(如果把以上的note:1换成note:2,那么i就是在栈区分配了，会随着foo的调用结束而释放)。<br>那么第二个问题也就浮出水面了，它是在第一次调用进入note:1的时候初始化（当初面试被坑过，我居然说是一开始就初始化了，汗！！）。且只初始化一次，也就是你第二次调用foo(),不会继续初始化，而会直接跳过。</p><p>那么它跟定义一个全局变量有什么区别呢，同样是初始化一次，连续调用foo()的结果是一样的，但是，使用全局变量的话，变量就不属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>　　静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p><p>那么我们总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：<br>（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);<br>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);<br>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);<br>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);</p><p>2.静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。</p><pre><code>static int i = 1;  //note:3//int i = 1;  //note:4</code></pre><p>​<br>    int foo()<br>    {<br>        i += 1;<br>        return i;<br>    }</p><p>note:3和note:4有什么差异呢？你调用foo(),无论调用几次，他们的结果都是一样的。也就是说在本文件内调用他们是完全相同的。那么他们的区别是什么呢？<br>文件隔离！</p><p>假设我有一个文件a.c,我们再新建一个b.c,内容如下。</p><pre><code>//file a.c //static int n = 15;  //note:5int n = 15;  //note:6 //file b.c#include &lt;stdio.h&gt; extern int n; void fn()&#123;    n++;    printf(&quot;after: %d\n&quot;,n);&#125;</code></pre><p>​<br>    void main()<br>    {<br>        printf(“before: %d\n”,n);<br>        fn();<br>    }</p><p>我们先使用note:6,也就是非静态全局变量，发现输出为:<br>before: 15<br>after: 16</p><p>也就是我们的b.c通过extern使用了a.c定义的全局变量。<br>那么我们改成使用note:5,也就是使用静态全局变量呢？<br>gcc a.c b.c -o output.out</p><p>会出现类似undeference to “n”的报错，它是找不到n的，因为static进行了文件隔离，你是没办法访问a.c定义的静态全局变量的，当然你用 #include “a.c”,那就不一样了。</p><p>以上我们就可以得出静态全局变量的特点：</p><p>静态全局变量不能被其它文件所用(全局变量可以);<br>其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);</p><p>3.静态函数：准确的说，静态函数跟静态全局变量的作用类似：</p><pre><code>//file a.c#include &lt;stdio.h&gt;</code></pre><p>​<br>    void fn()<br>    {<br>        printf(“this is non-static func in a”);<br>    }</p><p>​<br>    //file b.c<br>    #include &lt;stdio.h&gt;</p><p>​<br>    extern void fn();  //我们用extern声明其他文件的fn(),供本文件使用。</p><p>​<br>    void main()<br>    {<br>        fn();<br>    }</p><p>可以正常输出：this is non-static func in a。<br>当给void fn()加上static的关键字之后呢？ undefined reference to “fn”.</p><p>所以，静态函数的好处跟静态全局变量的好处就类似了：<br>1.静态函数不能被其它文件所用;<br>2.其它文件中可以定义相同名字的函数，不会发生冲突;</p><p>上面一共说了三种用法，为什么说准确来说是两种呢？<br>1.一种是修饰变量，一种是修饰函数，所以说是两种（这种解释不多）。<br>2.静态全局变量和修饰静态函数的作用是一样的，一般合并为一种。（这是比较多的分法）。</p><h2 id="C-语言的-static-关键字有二种用途："><a href="#C-语言的-static-关键字有二种用途：" class="headerlink" title="C++ 语言的 static 关键字有二种用途："></a>C++ 语言的 static 关键字有二种用途：</h2><p>当然以上的几种，也可以用在c++中。还有额外的两种用法：</p><p>1.静态数据成员：用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。</p><pre><code>#include&lt;iostream&gt;</code></pre><p>​<br>    using namespace std;</p><p>​<br>    class Rectangle<br>    {<br>    private:<br>        int m_w,m_h;<br>        static int s_sum;</p><pre><code>public:    Rectangle(int w,int h)    &#123;        this-&gt;m_w = w;        this-&gt;m_h = h;        s_sum += (this-&gt;m_w * this-&gt;m_h);    &#125;</code></pre><p>​<br>        void GetSum()<br>        {<br>            cout&lt;&lt;”sum = “&lt;&lt;s_sum&lt;&lt;endl;<br>        }</p><p>​<br>    };</p><p>​<br>    int Rectangle::s_sum = 0;  //初始化</p><p>​<br>​<br>​<br>    int main()<br>    {<br>        cout&lt;&lt;”sizeof(Rectangle)=”&lt;&lt;sizeof(Rectangle)&lt;&lt;endl;<br>        Rectangle *rect1 = new Rectangle(3,4);<br>        rect1-&gt;GetSum();<br>        cout&lt;&lt;”sizeof(rect1)=”&lt;&lt;sizeof(*rect1)&lt;&lt;endl;<br>        Rectangle rect2(2,3);<br>        rect2.GetSum();<br>        cout&lt;&lt;”sizeof(rect2)=”&lt;&lt;sizeof(rect2)&lt;&lt;endl;</p><pre><code>    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p>结果如下：</p><p>由图可知：sizeof(Rectangle)=8bytes=sizeof(m_w)+sizeof(m_h)。也就是说 static 并不占用Rectangle的内存空间。<br>那么static在哪里分配内存的呢？是的，全局数据区(静态区)。<br>再看看GetSum()，第一次12=3<em>4，第二次18=12+2</em>3。由此可得，static只会被初始化一次，于实例无关。<br>结论：</p><p>对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存。<br>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</p><p>也就是说，你每new一个Rectangle，并不会为static int s_sum的构建一份内存拷贝，它是不管你new了多少Rectangle的实例，因为它只与类Rectangle挂钩，而跟你每一个Rectangle的对象没关系。</p><p>2、静态成员函数：用于修饰 class 的成员函数。<br>我们对上面的例子稍加改动：</p><pre><code>#include&lt;iostream&gt;</code></pre><p>​<br>    using namespace std;</p><p>​<br>    class Rectangle<br>    {<br>    private:<br>        int m_w,m_h;<br>        static int s_sum;</p><pre><code>public:    Rectangle(int w,int h)    &#123;        this-&gt;m_w = w;        this-&gt;m_h = h;        s_sum += (this-&gt;m_w * this-&gt;m_h);    &#125;</code></pre><p>​<br>        static void GetSum()  //这里加上static<br>        {<br>            cout&lt;&lt;”sum = “&lt;&lt;s_sum&lt;&lt;endl;<br>        }</p><p>​<br>    };</p><p>​<br>    int Rectangle::s_sum = 0;  //初始化</p><p>​<br>​<br>​<br>    int main()<br>    {<br>        cout&lt;&lt;”sizeof(Rectangle)=”&lt;&lt;sizeof(Rectangle)&lt;&lt;endl;<br>        Rectangle *rect1 = new Rectangle(3,4);<br>        rect1-&gt;GetSum();<br>        cout&lt;&lt;”sizeof(rect1)=”&lt;&lt;sizeof(*rect1)&lt;&lt;endl;<br>        Rectangle rect2(2,3);<br>        rect2.GetSum();  //可以用对象名.函数名访问<br>        cout&lt;&lt;”sizeof(rect2)=”&lt;&lt;sizeof(rect2)&lt;&lt;endl;<br>        Rectangle::GetSum();  //也可以可以用类名::函数名访问</p><p>​<br>        system(“pause”);<br>        return 0;<br>    }</p><p>上面注释可见:对GetSum()加上static，使它变成一个静态成员函数，可以用类名::函数名进行访问。<br>那么静态成员函数有特点呢？<br>1.静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;<br>2.非静态成员函数可以任意地访问静态成员函数和静态数据成员;<br>3.静态成员函数不能访问非静态成员函数和非静态数据成员;<br>4.调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)</p><p>前三点其实是一点：静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态，有点晕吗？没关系，我给你个解释，<br>因为静态是属于类的，它是不知道你创建了10个还是100个对象，所以它对你对象的函数或者数据是一无所知的，所以它没办法调用，而反过来，你创建的对象是对类一清二楚的(不然你怎么从它那里实例化呢)，所以你是可以调用类函数和类成员的，就像不管GetSum是不是static，都可以调用static的s_sum一样。</p><h2 id="为什么静态成员不能在类内初始化"><a href="#为什么静态成员不能在类内初始化" class="headerlink" title="为什么静态成员不能在类内初始化"></a>为什么静态成员不能在类内初始化</h2><p>在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。</p><pre><code>class A&#123;  private:    static int count ; // 类内声明&#125;;int A::count = 0 ; // 类外初始化，不必再加static关键字</code></pre><p>为什么？因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><h2 id="C语言中-在一个函数中用-static修饰的变量，还能给它赋上新值吗？"><a href="#C语言中-在一个函数中用-static修饰的变量，还能给它赋上新值吗？" class="headerlink" title="C语言中 在一个函数中用 static修饰的变量，还能给它赋上新值吗？"></a>C语言中 在一个函数中用 static修饰的变量，还能给它赋上新值吗？</h2><p>可以，static在C语言中是表示一个变量为静态变量的，而不是常量，也不是不可变的变量。所谓的静态变量有两种情况，一种是静态全局变量，一种是静态局部变量。<br>先说静态局部变量：通常情况下，在一个函数中定义一个变量，那么函数退出之后，这个变量就消失了，即使你第二次调用这个函数，里面的变量也会被重新赋初值。比如我们写一个函数：</p><pre><code>int fun(int a)&#123;int sum;sum=sum+a;return sum;&#125;</code></pre><p>这样无论你是第几次调用fun这个函数，sum都会重新被赋初值，也就是函数的返回值一直会是a；而不会出现多次调用累加的情况。<br>但如果你在一个函数中，用static来声明变量，那么这个变量虽然在函数外部不可用，但退出函数时，这个变量是不会消失的，下一次再调用这个函数，里面的值仍然存在。就说上面这个函数，如果你的第一句写成static int sum;那么你第一次调用fun(3);函数返回3，第二次再调用fun(5);函数返回值是8,因为第一次调用之后的sum=3的值不会消失。<br>另一种是静态全局变量。因为是全局变量，不存在退出函数消不消失的问题。所以静态全局变量和普通全局变量的区别是：普通全局变量在其他源文件中可以通过extern全局变量名的声明，来使用该变量，而静态全局变量只能在变量所在的文件中使用，即使你在其他文件中使用extern声明也不可以使用，这样可以有效避免不同文件全局变量的冲突。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>频率、波长、传输距离、传输速率之间的关系，长波（LF），中波(MF)，短波(HF)，厘米波(SHF)，毫米波(EHF)频率范围波长的总结</title>
    <link href="/2019/05/30/%E9%A2%91%E7%8E%87%E3%80%81%E6%B3%A2%E9%95%BF%E3%80%81%E4%BC%A0%E8%BE%93%E8%B7%9D%E7%A6%BB%E3%80%81%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E9%95%BF%E6%B3%A2%EF%BC%88LF%EF%BC%89%EF%BC%8C%E4%B8%AD%E6%B3%A2(MF)%EF%BC%8C%E7%9F%AD%E6%B3%A2(HF)%EF%BC%8C%E5%8E%98%E7%B1%B3%E6%B3%A2(SHF)%EF%BC%8C%E6%AF%AB%E7%B1%B3%E6%B3%A2(EHF)%E9%A2%91%E7%8E%87%E8%8C%83%E5%9B%B4%E6%B3%A2%E9%95%BF%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <url>/2019/05/30/%E9%A2%91%E7%8E%87%E3%80%81%E6%B3%A2%E9%95%BF%E3%80%81%E4%BC%A0%E8%BE%93%E8%B7%9D%E7%A6%BB%E3%80%81%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E9%95%BF%E6%B3%A2%EF%BC%88LF%EF%BC%89%EF%BC%8C%E4%B8%AD%E6%B3%A2(MF)%EF%BC%8C%E7%9F%AD%E6%B3%A2(HF)%EF%BC%8C%E5%8E%98%E7%B1%B3%E6%B3%A2(SHF)%EF%BC%8C%E6%AF%AB%E7%B1%B3%E6%B3%A2(EHF)%E9%A2%91%E7%8E%87%E8%8C%83%E5%9B%B4%E6%B3%A2%E9%95%BF%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>一、波长越长穿透能力越强?波长越短贯穿能力越强?</p><p>是的,要区分穿透和贯穿这两个概念。</p><p>波长越长，绕射的能力越强，例如无限电波可以绕过高楼大厦传播、红灯的灯光比绿光和黄光更能穿透雾霭传播到远处以提醒司机；</p><p>波长越短，波的能量越大，贯穿能力越强，例如X光可贯穿皮肤、骨骼,紫外线能杀死细菌、强的紫外线能引起皮肤癌、穿越电离层等</p><p>根据：波速=波长*频率（频率和波长成反比例关系），则，</p><p>f=230MHz，  波长越长，绕射能力越强，穿透能力越强，信号损失衰减越小，传输距离越远，实现信号广覆盖。</p><p>f=1800MHz，波长越短，直射能力越强，贯穿能力越强，信号损失衰减越大，传输距离越短，杀伤力越强，实现信号局域覆盖。</p><p>注意：（波粒二象性：波长越短，能量越大，穿透能力越强）</p><p>基础知识：</p><p>1.波的频率和波长满足关系式：波速=波长×频率，所以频率不同的电磁波在真空中具有不同的波长。</p><p>2.电磁波在空间是向各个方向传播的，所有这些电磁波仅在波长（或频率）上有所差别，而在本质上完全相同，且波长不同的电磁波在真空中的传播速度都是电磁波的传播速度，即等于光速，是3x10e8米／秒。在空气中和在真空中近似。</p><p>3.不同频率(或不同波长)的电磁波的传播速度都相同，电磁波的频率愈高，相应的波长就越短。所以频率较大的电磁波，波长较短。无线电波的波长最长（频率最低），而射线的波长最短（频率最高）。</p><p>4.无线电频谱：通常无线电波所指的是从极低频10KHz到极超高频的顶点30GHz（Giga Hertz），因为超出这个范围以外的无线电频谱，其特性便有很大不同了，例如光线、X射线等，而在上述10KHz到30GHz，通常划分成七个区域，参看下表，其中高频3～30MHz就是我们通常所说的短波。<br><img src="https://img-blog.csdnimg.cn/20190530105216696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3ODgzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190530105257865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3ODgzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>无线电频谱的划分：<br>段号 频段名称 频段范围（含上限不含下限） 波段名称 波长范围（含上限不含下限）<br>1 甚低频（VLF） 3～30千赫（KHz） 甚长波 100～10km<br>2 低频（LF） 30～300千赫（KHz） 长波 10～1km<br>3 中频（MF） 300～3000千赫（KHz） 中波 1000～100m<br>4 高频（HF） 3～30兆赫（MHz） 短波 100～10m<br>5 甚高频（VHF） 30～300兆赫（MHz） 米波 10～1m<br>6 特高频（UHF） 300～3000兆赫（MHz） 分米波 微波 100～10cm<br>7 超高频（SHF） 3～30吉赫（GHz） 厘米波 10～1cm<br>8 极高频（EHF） 30～300吉赫（GHz） 毫米波 10～1mm<br>9 至高频 300～3000吉赫（GHz） 丝米波 1～0.1mm</p><ol start="5"><li>关于穿透性，波长越长，频率越低，穿透性越好（衍射，入和出不是同一个微波粒子）。</li></ol><p>7.频率越高，波长越短，能量越大，穿刺能力越强（同物体内部穿过，入和出是同一个微波粒子，如X射线Y射线）。且频率高带宽大，传输速率高，传播距离近（衍射能力弱，能量在穿刺工程中消耗）。</p><p>备注：</p><p>由于微波频率很高，所以在不大的相对带宽下，其可用的频带很宽（时域中时间相对越短，频域中相对越宽），可达数百甚至上千兆赫兹。这是低频无线电波无法比拟的。这意味着微波的信息容量大，所以现代多路通信系统，包括卫星通信系统，几乎无例外都是工作在微波波段。另外，微波信号还可以提供相位信息，极化信息，多普勒频率信息。这在目标检测，遥感目标特征分析等应用中十分重要<br>       微波的频率范围分为：<br>米波：波长10m→1m。频率30MHz→300MHz。<br>分米波：波长10dm→1dm。频率300MHz→3000MHz。<br>厘米波：波长10cm→1cm。频率3000MHz→30000MHz。<br>毫米波：波长10mm→1mm。频率3ooooMHz→300000MHz。</p><p>沿地面传播的无线电波叫地波，又叫表面波。电波的波长越短，越容易被地面吸收，因此只有长波和中波能在地面传播。地波不受气候影响，传播比较稳定可靠。但在传播过程中，能量被大地不断吸收，因而传播距离不远。所以地波适宜在较小范围里的通信和广播业务使用。</p><p>在无线信道通信中，频率较低的电磁波趋于沿弯曲的地球表面传播，有一定的绕射能力。这种传播方式成为地波传输。在低频和甚低频段，地波能够传播超过数百千米或数千千米<br>        沿地面传播的无线电波叫地波。当天线架设较低，且其沿地面方向为最大辐射方向时，主要是地波传播。地波传播的特点是信号比较稳定，基本上不受天气的影响，但随着电波频率的升高，传输损耗迅速增大。因此，这种方式更加适合长波的低频传输。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数字信号处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFT，DTFT，DFS，FFT之间的关系以及序列补零和插值对频域的影响</title>
    <link href="/2019/04/17/DFT%EF%BC%8CDTFT%EF%BC%8CDFS%EF%BC%8CFFT%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%BA%8F%E5%88%97%E8%A1%A5%E9%9B%B6%E5%92%8C%E6%8F%92%E5%80%BC%E5%AF%B9%E9%A2%91%E5%9F%9F%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2019/04/17/DFT%EF%BC%8CDTFT%EF%BC%8CDFS%EF%BC%8CFFT%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%BA%8F%E5%88%97%E8%A1%A5%E9%9B%B6%E5%92%8C%E6%8F%92%E5%80%BC%E5%AF%B9%E9%A2%91%E5%9F%9F%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="DFT，DTFT，DFS，FFT之间的关系"><a href="#DFT，DTFT，DFS，FFT之间的关系" class="headerlink" title="DFT，DTFT，DFS，FFT之间的关系"></a>DFT，DTFT，DFS，FFT之间的关系</h2><p>很多同学学习了数字信号处理之后，被里面的几个名词搞的晕头转向，比如DFT，DTFT，DFS，FFT，FT,FS等，FT和FS属于信号与系统课程的内容，是对连续时间信号的处理，这里就不过多讨论，只解释一下前四者的关系。</p><p>　　首先说明一下，这里只站在学生的角度以最浅显易懂的性质来解释问题，而不涉及到任何公式运算。</p><p>　　学过卷积，我们都知道有时域卷积定理和频域卷积定理，在这里只需要记住两点：1.在一个域的相乘等于另一个域的卷积；2.与脉冲函数的卷积，在每个脉冲的位置上将产生一个波形的镜像。(在任何一本信号与系统课本里，此两条性质有详细公式证明)</p><p>　　下面，就用这两条性质来说明DFT，DTFT，DFS，FFT之间的联系：</p><p>　　先看图片：<br><img src="https://img-blog.csdnimg.cn/20190417213553164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3ODgzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>　　首先来说图（1）和图（2），对于一个模拟信号，如图(1)所示，要分析它的频率成分，必须变换到频域，这是通过傅立叶变换即FT(Fourier Transform)得到的，于是有了模拟信号的频谱，如图(2)；注意1：时域和频域都是连续的！</p><p>　　但是，计算机只能处理数字信号，首先需要将原模拟信号在时域离散化，即在时域对其进行采样，采样脉冲序列如图(3)所示，该采样序列的频谱如图(4)，可见它的频谱也是一系列的脉冲。所谓时域采样，就是在时域对信号进行相乘，(1)×(3)后可以得到离散时间信号x[n]，如图(5)所示；由前面的性质1，时域的相乘相当于频域的卷积，那么，图(2)与图(4)进行卷积，根据前面的性质2知，会在各个脉冲点处出现镜像，于是得到图(6)，它就是图(5)所示离散时间信号x[n]的DTFT(Discrete time Fourier Transform)，即离散时间傅立叶变换，这里强调的是“离散时间”四个字。注意2：此时时域是离散的，而频域依然是连续的。</p><p>　　经过上面两个步骤，我们得到的信号依然不能被计算机处理，因为频域既连续，又周期。我们自然就想到，既然时域可以采样，为什么频域不能采样呢？这样不就时域与频域都离散化了吗？没错，接下来对频域在进行采样，频域采样信号的频谱如图(8)所示，它的时域波形如图(7)。现在我们进行频域采样，即频域相乘，图(6)×图(8)得到图(10)，那么根据性质1，这次是频域相乘，时域卷积了吧，图(5)和图(7)卷积得到图(9)，不出所料的，镜像会呈周期性出现在各个脉冲点处。我们取图（10）周期序列的主值区间，并记为X(k)，它就是序列x[n]的DFT(Discrete Fourier Transform)，即离散傅立叶变换。可见，DFT只是为了计算机处理方便，在频率域对DTFT进行的采样并截取主值而已。有人可能疑惑，对图(10)进行IDFT，回到时域即图(9)，它与原离散信号图(5)所示的x[n]不同呀，它是x[n]的周期性延拓！没错，因此你去查找一个IDFT的定义式，是不是对n的取值区间进行限制了呢？这一限制的含义就是，取该周期延拓序列的主值区间，即可还原x[n]！</p><p>　　FFT呢？FFT的提出完全是为了快速计算DFT而已，它的本质就是DFT！我们常用的信号处理软件MATLAB或者DSP软件包中，包含的算法都是FFT而非DFT。</p><p>　　DFS,是针对时域周期信号提出的，如果对图(9）所示周期延拓信号进行DFS，就会得到图(10)，只要截取其主值区间，则与DFT是完全的一一对应的精确关系。这点对照DFS和DFT的定义式也可以轻易的看出。因此DFS与DFT的本质是一样的，只不过描述的方法不同而已。</p><p>　　不知道经过上面的解释，您是否明白各种T的关系了呢？如果您不是算法设计者，其实只要懂得如何使用FFT分析频谱即可，博主近期会更新一篇文章，专门介绍如何利用FFT分析简单信号的频谱。</p><p>　　其实个人认为，纠结了这么多，就是为了打破现实模拟世界与计算机数字世界的界限呀！</p><h2 id="序列补零和插值对频域的影响"><a href="#序列补零和插值对频域的影响" class="headerlink" title="序列补零和插值对频域的影响"></a>序列补零和插值对频域的影响</h2><p>连续时间信号经采样、截断后的序列为Xn(n)，其频谱函数XN(ejw)，并不随序列末端补零而改变，信号的频率分辨率为Fs/N.序列末端补零只能提高信号频谱显示的分辨率。换句话说，如果连续时间信号在离散化或时域加窗截断过程中，由于频谱泄漏或混叠等原因已造成信号频谱中信息的失真，则无论怎么补零做DFT，都无法再恢复已损失的信息。<br>　　提高信号的频率分辨率只有提高信号的采样频率或增加序列的截断长度N(信号的持续时间加长)。<br>1）数据后面补零——-不能提高信号的频率分辨率<br>　　序列末端补零后，尽管信号的频谱不会变化，但对序列做补零后L点DFT后，计算出的频谱实际上是原信号频谱在[0,2*pi)区间上L个等间隔采样，从而增加了对真实频谱采样的点数，并改变了采样点的位置，这将会显示出原信号频谱的更多的细节。故而数据后面补零可以克服栅栏效应。<br>2）数据间隔补零——-不能提高信号的频率分辨率<br>3）数据插值<br>相当于提高了信号的采样率，可以提高信号的频率分辨率</p>]]></content>
    
    
    
    <tags>
      
      <tag>DFT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字角频率和模拟角频率和物理频率和归一化角频率的关系，及FFT频率和实际物理频率的关系分析</title>
    <link href="/2019/03/22/%E6%95%B0%E5%AD%97%E8%A7%92%E9%A2%91%E7%8E%87%E5%92%8C%E6%A8%A1%E6%8B%9F%E8%A7%92%E9%A2%91%E7%8E%87%E5%92%8C%E7%89%A9%E7%90%86%E9%A2%91%E7%8E%87%E5%92%8C%E5%BD%92%E4%B8%80%E5%8C%96%E8%A7%92%E9%A2%91%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%8F%8AFFT%E9%A2%91%E7%8E%87%E5%92%8C%E5%AE%9E%E9%99%85%E7%89%A9%E7%90%86%E9%A2%91%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90/"/>
    <url>/2019/03/22/%E6%95%B0%E5%AD%97%E8%A7%92%E9%A2%91%E7%8E%87%E5%92%8C%E6%A8%A1%E6%8B%9F%E8%A7%92%E9%A2%91%E7%8E%87%E5%92%8C%E7%89%A9%E7%90%86%E9%A2%91%E7%8E%87%E5%92%8C%E5%BD%92%E4%B8%80%E5%8C%96%E8%A7%92%E9%A2%91%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%8F%8AFFT%E9%A2%91%E7%8E%87%E5%92%8C%E5%AE%9E%E9%99%85%E7%89%A9%E7%90%86%E9%A2%91%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="4种频率及其数量关系"><a href="#4种频率及其数量关系" class="headerlink" title="4种频率及其数量关系"></a>4种频率及其数量关系</h2><p>实际物理频率表示AD采集物理信号的频率，fs为采样频率，由奈奎斯特采样定理可以知道，fs必须≥信号最高频率的2倍才不会发生信号混叠，因此fs能采样到的信号最高频率为fs/2。</p><p>Ω角频率是物理频率f的2*pi倍，这个也称模拟频率。</p><p>归一化频率是将物理频率按fs归一化之后的结果，最高的信号频率为fs/2对应归一化频率0.5，这也就是为什么在matlab的fdtool工具中归一化频率为什么最大只到0.5的原因。</p><p>圆周频率是归一化频率的2*pi倍，这个也称数字频率ω。</p><pre><code>Ω=2πf；ω=ΩT=Ω/fs=2πf/fs=2π Ω/Ωs</code></pre><p><img src="https://img-blog.csdnimg.cn/20190322212317899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3ODgzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="有关FFT频率与实际物理频率的分析"><a href="#有关FFT频率与实际物理频率的分析" class="headerlink" title="有关FFT频率与实际物理频率的分析"></a>有关FFT频率与实际物理频率的分析</h2><p>做n个点的FFT，表示在时域上对原来的信号取了n个点来做频谱分析，n点FFT变换的结果仍为n个点。</p><p>换句话说，就是将2pi数字频率w分成n份，而整个数字频率w的范围覆盖了从0-2pi*fs的模拟频率范围。这里的fs是采样频率。而我们通常只关心0-pi中的频谱，因为根据奈科斯特定律，只有f=fs/2范围内的信号才是被采样到的有效信号。那么，在w的范围内，得到的频谱肯定是关于n/2对称的。</p><p>举例说，如果做了16个点的FFT分析，你原来的模拟信号的最高频率f=32kHz，采样频率是64kHz，n的范围是0,1,2…15。这时，64kHz的模拟频率被分成了16分，每一份是4kHz，这个叫频率分辨率。那么在横坐标中，n=1时对应的f是4kHz, n=2对应的是8kHz, n=15时对应的是60kHz，你的频谱是关于n=8对称的。你只需要关心n=0到7以内的频谱就足够了，因为，原来信号的最高模拟频率是32kHz。</p><p>这里可以有两个结论。</p><p>第一，必须知道原来信号的采样频率fs是多少，才可以知道每个n对应的实际频率是多少，第k个点的实际频率的计算为f(k)=k*(fs/n)<br>第二，你64kHz做了16个点FFT之后，因为频率分辨率是4kHz，如果原来的信号在5kHz或者63kHz有分量，你在频谱上是看不见的，这就表示你越想频谱画得逼真，就必须取越多的点数来做FFT，n就越大，你在时域上就必须取更长的信号样本来做分析。但是无论如何，由于离散采样的原理，你不可能完全准确地画出原来连续时间信号的真实频谱，只能无限接近（就是n无限大的时候），这个就叫做频率泄露。在采样频率fs不变得情况下，频率泄漏可以通过取更多的点来改善，也可以通过做FFT前加窗来改善，这就是另外一个话题了。</p><h2 id="用DFT进行谱分析的误差问题"><a href="#用DFT进行谱分析的误差问题" class="headerlink" title="用DFT进行谱分析的误差问题"></a>用DFT进行谱分析的误差问题</h2><p>DFT可用来对连续信号和数字信号进行谱分析，在实际分析过程中，要对连续信号采样和截断，就会引发误差，下面介可能产生误差的三种现象。<br>（1）混叠现象。对连续信号进行谱分析是，首先要对其采样，变成时域离散信号后才能用DFT(FFT)进行谱分析。采样速率Fs必须满足奈奎斯特采样定理，否则会在Fs/2附近发生频谱混叠现象。<br>（2）栅栏效应（栅栏现象，也称栅栏效应，对一函数实行采样，即是抽取采样点上的对应的函数值。其效果如同透过栅栏的缝隙观看外景一样，只有落在缝隙前的少数景象被看到，其余景象均被栅栏挡住而视为零，这种现象称为栅栏效应。）。N点DFT是在频率区间[0，2π]上对时域离散信号的频谱进行N点等间隔采样，而采样点之间的频谱是看不到的。就像上文中举的例子，原来信号可能会在5KHz出有频谱的分量，但我们的频率分辨率只有8KHz，这就导致我们无法观察在5KHz的分量。要想观察，我们就必须提高频率分辨率。对于有限长序列，可以在原序列尾部补零；对于无限长序列，可以增大截取长度及DFT变换区间长度，从而使频域采样间隔变小，增加频域采样点数和采样点位置，使原来漏掉的某些频谱分量被检测出来。对于连续信号的谱分析，只要采样速率Fs足够高，且采样点数满足频率分辨率要求，就可以认为DFT后所得离散谱的包络近似代表原信号的频谱。<br>（3）截断效应。实际中遇到的序列x(n)可能无限长的，用DFT进行谱分析时，必须将其截断，形成有限长序列。而截断后序列的频谱必将发生变化。主要有两个方面：<br>①泄露 ：原来的序列的频谱是离散谱线，经截断后，使原来的离散谱线向附近展宽。通常称这种展宽为泄露。泄露使频谱变模糊，频率分辨率降低。<br>②谱间干扰。</p><h2 id="离散信号傅里叶变换的周期性讨论"><a href="#离散信号傅里叶变换的周期性讨论" class="headerlink" title="离散信号傅里叶变换的周期性讨论"></a>离散信号傅里叶变换的周期性讨论</h2><p>要分析这个，我们先从Laplace变换与Z变换之间的关系谈起。</p><p>由，得z平面与s平面的关系图<br><img src="https://img-blog.csdnimg.cn/20190322212536768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3ODgzNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图中的关系有以下几点：</p><p>s平面的虚轴映射到z平面的单位圆上<br>s平面的负半轴映射到z平面的单位圆内<br>s平面的正半轴映射到z平面的单位圆外<br>Laplace变换是用于连续信号的变换，相对应的z变换是应用到z平面的变换。因此从另一个角度，上面谈到的角频率（模拟频率）对应的是s平面，圆周频率对应的是z平面（也是为什么称为圆周频率的原因）。</p><p>现在我们来看一下s平面虚轴上模拟频率的变换将会导致z平面单位圆上如何变化：</p><p>当模拟频率在s平面的虚轴上从0变到fs 时，数字频率在z平面单位圆上从0变到2 pi。<br>当模拟频率在s平面的虚轴上从2fs变到4fs时，数字频率在z平面单位圆上仍然从0变到2 pi。<br>。。。。。。z平面如此循环重复<br>我们知道离散信号的傅里叶变换对应到单位圆上的z变换，因此上面的结论就验证了为什么离散信号的傅里叶变换是周期性：根本原因所是单位圆上的周期性。</p><p>考虑到我们实际应用中可选择一个周期，这也能够解释：因为实际信号的频率总是在fs/2以下，这就对应到z平面单位圆上的0~pi，在一个周期范围内就可以进行信号分析了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>FFT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
